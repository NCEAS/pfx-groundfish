---
title: "Local vs Regional Stability of Gulf of Alaksa Groundfish Assemblages"
author: "Colette Ward"
date: "July 12, 2016"
output: pdf_document
---


```{r, include=FALSE, echo=FALSE, results='hide'}
# Load packages
library(plyr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(gridExtra)

```


```{r,  include=FALSE, echo=FALSE, results='hide'}
# load & prep look-up table of common names
common <- read.csv("./diversity-data/trawl_species_control_file.csv", header = T, stringsAsFactors = FALSE)

common1 <- common %>%
  select(database.name, common.name) %>%
  rename(Species = database.name)
for (i in 1:nrow(common1)) { # add common names for Sebastes 1 & 2
  if(common1$Species[i] == "Dusky.and.Dark.Rockfish") {common1$common.name[i] <- "Sebastes 1"}
  if(common1$Species[i] == "Rougheye.and.Blackspotted.Rockfish") {common1$common.name[i] <- "Sebastes 2"}
}



# load area file
area <- read.csv("./spatial-portfolio-project/local-community-area.csv", header = T, stringsAsFactors = F) # note area numbers do not need updating; they reflect remove Ole's area 8

```


```{r,  include=FALSE, echo=FALSE, results='hide'}
# load mean annual CPUE data for Shallow Areas:
shallowCPUEArea <- read.csv("./diversity-data/All_sp_index_meanCPUEByArea.csv", header = T, stringsAsFactors = FALSE)

shallowCPUEArea2 <- left_join(shallowCPUEArea, common1, by = "Species") %>% # merge common names onto SPCPUEArea
  select(area, Mean.totalDensity, SD.totalDensity, year, Species, common.name) %>%
  filter(area != "8") %>% # remove Ole's area 8
  mutate(area = revalue(area, c("9"="8", "10"="9", "11"="10"))) %>% # renumber (old = new) shallow areas to account for splitting area 7 into 7, 8, 9 but removing 8
  mutate(area = revalue(area, c("Total" = "Region"))) %>%
  left_join(area, by = "area")

```

```{r,  include=FALSE, echo=FALSE, results='hide'}
# load mean annual CPUE for Deep areas:
deepCPUEArea <- read.csv("../diversity-data/All_sp_index_meanCPUEByArea.Deep.MH.final.csv", header = T, stringsAsFactors = FALSE) # this is the latest file created by Mary Oct 26 2016

deepCPUEArea2 <- left_join(deepCPUEArea, common1, by = "Species") %>% # merge in common names
  select(area, Mean.totalDensity, SD.totalDensity, year, Species, common.name) %>%
  mutate(area = revalue(area, c("1"="11", "2"="12", "3"="14", "4"="15", "5"="13", "Total" = "Region")))  %>% # renumbering areas
  left_join(area, by = "area")

```


To address local vs regional community stability we can compare CVs of total CPUE between local communities and the regional metacommunity.
The regional community does indeed show greater stability than local communities. Note that y-axis scales differ - deep areas are generally less stable than shallow areas.  
**The magnitude of the portfolio effect can be assessed from the ratio of mean local CV / regional CV (ie the increase in stability that arises from spatial (beta) diversity; values >1 indicate a stabilizing effect): the ratio is ~2.3 for shallow areas and ~1.4 for deep areas.** (I'm not sure the difference between effect size in shallow and deep is meaningful, it may arise because we have more local patches for shallow areas.)  
[If anyone wants to make these plots prettier, please do :) ]

```{r, echo=F, fig.height=3.5, fig.width=8}

# Shallow areas:
CV_shallow <- shallowCPUEArea2 %>% 
  group_by(area, year) %>%
  summarise(total = sum(Mean.totalDensity)) %>%
  ungroup() %>%
  
  group_by(area) %>%
  summarise(CV = sd(total) / mean(total)) %>%
  ungroup() %>%
  
  left_join(area, by = "area") # add area data

# mean CV of shallow local areas
# CV_shallow %>%
#   filter(area != "Total") %>%
#   summarise(mean = mean(CV), sd = sd(CV))
# 0.171/0.073 # ratio of mean local / regional = 2.342 for shallow areas


# plot on a log scale
CV_shallow_plot <- ggplot(data=CV_shallow, aes(x=area, y = CV)) + 
  geom_point(aes(y = CV), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=12), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=12),
        axis.title.x=element_text(size=12, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=12, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  
  scale_x_discrete(limits=c(1:10, "Region")) +

  scale_y_log10(breaks = c(0.07, 0.08, 0.09, 0.1, 0.15, 0.2)) +
  
  labs(x = "Local Community", y = "CV (Total CPUE)", title = "Shallow Areas")



##############################

# Deep areas:
CV_deep <- deepCPUEArea2 %>% 
  group_by(area, year) %>%
  summarise(total = sum(Mean.totalDensity)) %>%
  ungroup() %>%
  
  group_by(area) %>%
  summarise(CV = sd(total) / mean(total)) %>%
  ungroup()

# mean CV of deep local areas
# CV_deep %>%
#   filter(area != "Total") %>%
#   summarise(mean = mean(CV), sd = sd(CV))
# 0.253/0.187 # ratio of mean local / regional = 1.353 for deep areas


# plot on a log scale
CV_deep_plot <- ggplot(data=CV_deep, aes(x=area, y = CV)) + 
  geom_point(aes(y = CV), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=12), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=12),
        axis.title.x=element_text(size=12, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=12, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  
  scale_y_log10(breaks = c(0.15, 0.2, 0.25, 0.3, 0.35, 0.4)) +
  
  labs(x = "Local Community", y = "CV (Total CPUE)", title = "Deep Areas")



grid.arrange(CV_shallow_plot, CV_deep_plot, ncol=2)


##########

# plot CV vs area
ggplot(data=CV_shallow, aes(x=km2, y = CV)) + 
  geom_point(aes(y = CV), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=10), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=10),
        axis.title.x=element_text(size=12, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=12, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  
  #scale_x_discrete(limits=c(1000, 5000, 10000, 20000, 30000, 40000, 50000, "Region")) +
  
  scale_x_log10(breaks = c(5000, 10000, 20000, 30000, 40000)) +

  scale_y_log10(breaks = c(0.07, 0.08, 0.09, 0.1, 0.15, 0.2)) +
  
  labs(x = "Area of Local Community (km2)", y = "CV (Total CPUE)", title = "Shallow Areas")

```


```{r, echo=FALSE, fig.height=3.5, fig.width=8}

# Calculate & plot CV vs Area (km^2)

CV_Area_func <- function(my_df, spatialGrouping){
  
  CV_agg_list <- list()
  Area_agg_list <- list()
  df_list <- list()
  
  for(i in seq_along(spatialGrouping)) {
  
                CV_agg_list[[i]] <- my_df %>%
                          filter(area %in% spatialGrouping[[i]]) %>%
                          group_by(year) %>%
                          summarise(total = sum(Mean.totalDensity)) %>%
                          ungroup() %>%
                          summarise(CV = sd(total) / mean(total))
  
                Area_agg_list[[i]] <- my_df %>%
                            filter(area %in% spatialGrouping[[i]]) %>%
                            select(area, km2) %>%
                            group_by(area) %>%
                            summarise(eachArea = first(km2)) %>%
                            ungroup() %>%
                            summarise(area_agg = sum(eachArea))
  }
  
  df_list <- list(Area_agg_list, CV_agg_list)
  my_df <- as.data.frame(matrix(unlist(df_list), nrow=length(unlist(df_list[1]))))
  colnames(my_df) <- c("Area", "CV")
  return(my_df)
  
}


############

a <- list(1); b <- list(1:2); c <- list(1:3); d <- list(1:4); e <- list(1:5)
f <- list(1:6); g <- list(1:7); h <- list(1:8); k <- list(1:9); l <- list(1:10)
corner1_list <- c(a, b, c, d, e, f, g, h, k, l)

m <- list(10); q <- list(9:10); r <- list(8:10); s <- list(7:10); t <- list(6:10)
u <- list(5:10); v <- list(4:10); w <- list(3:10); z <- list(2:10); zz <- list(1:10)
corner10_list <- c(m, q, r, s, t, u, v, w, z, zz)


corner1 <- CV_Area_func(shallowCPUEArea2, corner1_list)
for(i in 1:nrow(corner1)) {
  corner1$startingFrom[[i]] <- "East -> West" 
}

corner10 <- CV_Area_func(shallowCPUEArea2, corner10_list)
for(i in 1:nrow(corner10)) {
  corner10$startingFrom[[i]] <- "West -> East" 
}

plotting_df <- rbind(corner1, corner10)


############

ggplot(data=plotting_df, aes(x=Area, y = CV, color = startingFrom)) + 
  #geom_point(aes(y = CV), size=2) +
  geom_line(aes(y = CV), size = 1) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=12), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=12),
        axis.title.x=element_text(size=12, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=12, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  
  scale_x_log10(breaks = c(5000, 10000, 20000, 30000, 40000), labels = c(5000, 10000, 20000, 30000, 40000)) +
  
  labs(x = "Area (km^2)", y = "CV of Total Community CUE")


```


```{r, echo=FALSE, fig.height=3.5, fig.width=8}

# Calculate and plot Species Richness (gamma) vs Area

# load occurrence data
occDat <-read.csv("./diversity-data/All_sp_index_occurrenceByArea.Shallow.MH.final.csv", header = T, stringsAsFactors = FALSE)
#View(occDat)

area1 <- area %>%
  filter(area != "Region") %>%
  mutate(area = as.numeric(area))

occDat1 <- occDat %>%
  select(area, year.numb, Species, Mean.avgPresence) %>%
  left_join(area1, by = "area")


Richness_Area_func <- function(my_df, spatialGrouping){
  
  richness_agg_list <- list()
  Area_agg_list <- list()
  df_list <- list()
  
  for(i in seq_along(spatialGrouping)) {
    
    richness_agg_list[[i]] <- occDat %>%
      filter(area %in% spatialGrouping[[i]]) %>%
      
      group_by(year.numb, Species) %>%
      summarize(presenceBySpecies = max(Mean.avgPresence)) %>% # take maximum probability of occurrence of each species, in each year, for each spatialGrouping
      ungroup() %>%
      
      group_by(year.numb) %>%
      summarize(spPresenceByYear = sum(presenceBySpecies)) %>% # spRichness for each year = sum of all presenceBySpecies, across all species
      ungroup() %>%

      summarize(spRichness = mean(spPresenceByYear)) %>% # mean spRichness across all years for each spatialGrouping
      ungroup()
    
    
    Area_agg_list[[i]] <- my_df %>%
                            filter(area %in% spatialGrouping[[i]]) %>%
                            select(area, km2) %>%
                            group_by(area) %>%
                            summarise(eachArea = first(km2)) %>%
                            ungroup() %>%
                            summarise(area_agg = sum(eachArea))
  }
  
  df_list <- list(Area_agg_list, richness_agg_list)
  my_df <- as.data.frame(matrix(unlist(df_list), nrow=length(unlist(df_list[1]))))
  colnames(my_df) <- c("Area", "speciesRichness")
  return(my_df)
  
}


############

a <- list(1)
b <- list(2)
c <- list(3)
d <- list(4)
e <- list(5)
f <- list(6)
g <- list(7)
h <- list(8)
k <- list(9)
l <- list(10)
m <- list(1:4)
n <- list(5:7)
o <- list(8:10)
q <- list(1:10)
big_list <- c(a, b, c, d, e, f, g, h, k, l, m, n, o, q)


richness1 <- Richness_Area_func(occDat1, big_list)
View(richness1)


############

# plot the result

ggplot(data=richness1, aes(x=Area, y = speciesRichness)) + 
  geom_point(aes(y = speciesRichness), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=12), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=12),
        axis.title.x=element_text(size=14, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=14, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  
  scale_x_log10(breaks = c(5000, 10000, 20000, 30000, 40000), labels = c(5000, 10000, 20000, 30000, 40000)) +
  
  labs(x = "Area (km^2)", y = "Species Richness (summed probability of occurrence)")


############


# Mary's code for bootstrapping Species Richness using beta distribution:

### Beta Method of Moments - for occurrence data
#beta.mom <- function(MEAN,SD){
#  VAR   <- SD^2
#  alpha <- MEAN * ((MEAN *(1 - MEAN)) / VAR - 1)
#  beta  <- (1-MEAN) * ((MEAN *(1 - MEAN)) / VAR - 1)
#  OUT   <- list(alpha=alpha,beta=beta) 
#  #return(OUT)
#  return(list(alpha=alpha,beta=beta))
#}

#b <- beta.mom(datj$Mean.avgPresence,datj$SD.totalPresence)

#      for(b in 1:BootstrapLength){
        
#        #  generate a vector of abundance / species in ab
#        obs.sp <- rbeta(1:length(ab$alpha),ab$alpha,ab$beta) ##################
        
        #calculate diversity metrcs
#        year=years[i] 
#        area=areas[j] 
#        Sp_rich <- sum(obs.sp)
        
        

```



Although we can compare local and regional community stability using CVs alone, here we calculate metrics from Wang & Loreau (2014) to help us think about mechanisms underlying this result.
The following uses formulas from Wang & Loreau's (2014) Supp Mat (i.e. for the case where biomass varies within and between local communities).
```{r,  include=FALSE, echo=FALSE, results='hide'}

# CONSIDER WHETHER TO LOG THE CUES FIRST


# note: for applying this to our spatial groupings, your_df should have a column called spatialGrouping, which contains the grouping code
WangLoreau_func <- function(your_df){
  
  #shallowAreas_list <- split(your_df, f = your_df$area) # create a list of dataframes (one df for each local area)
  shallowAreas_list <- split(your_df, f = your_df$spatialGrouping) # create a list of dataframes (one df for each spatial group)

  # nomenclature for the following calculations:
  # i, h = local community i (and h)
  # j, k, l = species j, k, l
  # j_i = species j in local community i
  # u = mean
  # w = variance or covariance
  # w_kk_i = variance of each species k within local community i
  # w_kl_i = covariance between species k and l within local community i
  # w_ii = variance (of total community CPUE) for each local community i
  # w_ih = covariance (of total community CPUE) between local communities i & h
  # rho = temporal Synchrony; inverse is Beta (temporal Asynchrony)


  A_list <- list(); B_list <- list(); C_list <- list(); D_list <- list(); E_list <- list(); F_list <- list()
  covMatrix_i_list <- list(); w_kk_i_list <- list(); rho_species_i_list <- list(); CV_i_list <- list()

  
  
  for(i in seq_along(shallowAreas_list)) {
    
  # 1. Calculate averaged species variability (C_list[[i]]$CV_species_i_squared):
  
  # calculate local community-level stuff
    A_list[[i]] <- shallowAreas_list[[i]] %>%
      group_by(year) %>%
      summarise(annual_total_i = sum(Mean.totalDensity)) %>%
      ungroup() %>%
      summarise(var_i = var(annual_total_i),
                stDev_i = sqrt(var(annual_total_i)),
                u_i = mean(annual_total_i)) # mean total community biomass (across all years) for local community i
    
  
  # calculate species-level stuff
    B_list[[i]] <- shallowAreas_list[[i]] %>%
      group_by(Species) %>%
      summarise(u_j_i = mean(Mean.totalDensity), # mean biomass (across all years) of species j in local community i
                CV_j_i_squared = var(Mean.totalDensity) / (u_j_i)^2 , # CV of species j in local community i. Note the usual formula for CV is squared
                CV_species_j_i = u_j_i / A_list[[i]]$u_i * CV_j_i_squared) %>% # CV of species in local community i
      ungroup()
  
  
  # calculate averaged species variability
    C_list[[i]] <- B_list[[i]] %>%
      summarise(CV_species_i_squared = sum(CV_species_j_i))
  
  
  ##############################
  # 2. Calculate species asynchrony WITHIN local areas (rho_species_i_list[[i]]):
    D_list[[i]] <- shallowAreas_list[[i]] %>%
      select(year, Mean.totalDensity, Species) %>%
      spread(Species, Mean.totalDensity) %>%
      select(-year)
    
    
    covMatrix_i_list[[i]] <- cov(D_list[[i]]) # create the covariance matrix
    
    
    w_kk_i_list[[i]] <- diag(covMatrix_i_list[[i]]) # extract diagonals of the covariance matrix. these are temporal variance of each species k within local community i
    
    
    covMatrix_i_list[[i]][upper.tri(covMatrix_i_list[[i]], diag = TRUE)] <- NA # for each local community i, keep one copy of all the non-diagonals. these are w_kl_i
    E_list[[i]] <- as.data.frame(covMatrix_i_list[[i]])
    
    
    F_list[[i]] <- E_list[[i]] %>%
      summarise(sum_w_kl_i = sum(E_list[[i]][,1:53], na.rm = T)) # for each local community i, find the sum of all w_kl_i. calc has been checked
    
    
    rho_species_i_list[[i]] <- F_list[[i]]$sum_w_kl_i / ((sum(sqrt(w_kk_i_list[[i]][1:53])))^2)
  
  
  ##############################
  # 3. Calculate Variability of local community i (CV_i_list[[i]])
    CV_i_list[[i]] <- C_list[[i]]$CV_species_i_squared * rho_species_i_list[[i]]
   #CV_i_list[[i]] <- (C_list[[i]]$CV_species_i_squared * rho_species_i_list[[i]])^2 # It's not clear whether this should be squared. If not squred, returns a negative value when within-patch species synchrony is negative.
      
  # CHECK WHETHER LOCAL COMMUNITY VARIABILITY CORRELATES WITH SIZE (AREA) OF LOCAL COMMUNITY (IE DO LARGER AREAS SHOW MORE VARIABILITY?)
  
  
  ##############################
  # 4. Calculate Alpha variability (local community variability weighed for local community biomass; alpha_CV_list[[i]])
    u_m <- sum(A_list[[i]]$u_i)
    alpha_CV <- (sum(A_list[[i]]$u_i / u_m * CV_i_list[[i]] ))^2 # It's not clear whether this should be squared.
    
    }

  
  ##############################
  # 5. Calculate Beta variability (spatial synchrony; rho)
  # note I'm replacing Wang & Loreau's local patch i & j notation with i & h, to avoid confusion with species j

  shallowCPUEArea3 <- your_df %>%  
    filter(area != "Total") %>%
    group_by(area, year) %>%
    summarise(ann_tot_i = sum(Mean.totalDensity)) %>%
    ungroup() %>%
    spread(area, ann_tot_i) %>%
    select(-year)
  
  
  covMatrix_m <- cov(shallowCPUEArea3) # create the covariance matrix
  
  w_ii <- diag(covMatrix_m) # extract diagonals of the covariance matrix. returns a vector. this is temporal variance of total community CPUE, within each local community.
  
  covMatrix_m[upper.tri(covMatrix_m, diag = TRUE)] <- NA # keep one copy of all the non-diagonals. These are w_ih (temporal covariance of total community biomass between local patches i & h). NB it would be nice to bring in species-level information here, to prevent dominant species from driving the result.
  w_ih <- as.data.frame(covMatrix_m)
  
  summed_w_ih <-w_ih %>% summarise(sum_w_ih = sum(w_ih[,1:9], na.rm = T)) # find the sum of all w_ih. calc has been checked
  
  rho <- summed_w_ih$sum_w_ih / ((sum(sqrt(w_ii[1:9])))^2) # Wang & Loreau (2014) claim that standardizing for within-patch covariance accounts for spatial uneveness in biomass. Not sure about this.
  Beta1 <- 1 / rho
  

  ##############################
  # 6. Calculate Gamma variability
  
  gamma_CV <- alpha_CV / Beta1
  
  return(gamma_CV)
}



WangLoreau_func(shallowCPUEArea2) # test the function ... result is as expected.
  
```


###Within-patch sums of all between-species covariances. Negative values indicate asynchrony.
```{r, echo=F, fig.height=2.75, fig.width=4}
# F_list
F_df <- data.frame(matrix(NA_real_, nrow = 9, ncol = 2)); 
colsF <- c("Area", "sum_w_kl_i"); colnames(F_df) <- colsF
areaNum <- as.vector(1:9); F_df[,1] <- as.factor(areaNum)

for(i in seq_along(F_list)) {
  F_df[i,2] <- data.frame(as.data.frame(F_list[[i]]$sum_w_kl_i))
}


# plot
cov.within_shallow <- ggplot(data=F_df, aes(x=areaNum, y = sum_w_kl_i)) + 
  geom_point(aes(y = sum_w_kl_i), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black")) +
  
  scale_x_continuous(breaks = c(1:9)) +
  
  labs(x = "Area", y = "sum_w_kl_i", title = "Shallow Areas")

cov.within_shallow
```


```{r, include=FALSE, echo=FALSE, results='hide'}
# Within-patch species asynchrony:
# rho_species_i_list
rho_sp_df <- data.frame(matrix(NA_real_, nrow = 9, ncol = 2)); 
cols_rho_sp <- c("Area", "rho_species_i"); colnames(rho_sp_df) <- cols_rho_sp
areaNum <- as.vector(1:9); rho_sp_df[,1] <- as.factor(areaNum)

for(i in seq_along(rho_species_i_list)) {
  rho_sp_df[i,2] <- data.frame(as.data.frame(rho_species_i_list[[i]]))
}


# plot
asynch.within <- ggplot(data=rho_sp_df, aes(x=areaNum, y = rho_species_i)) + 
  geom_point(aes(y = rho_species_i), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black")) +
  
  scale_x_continuous(breaks = c(1:9)) +
  
  labs(x = "Area", y = "rho_species_i")

asynch.within
```


```{r, include=FALSE, echo=FALSE, results='hide'}
# Within-patch variability (ie CVs of total community CPUE within local communities):
# CV_i_list
CV_i_df <- data.frame(matrix(NA_real_, nrow = 9, ncol = 2)); 
cols_CV_i <- c("Area", "CV_i"); colnames(CV_i_df) <- cols_CV_i
areaNum <- as.vector(1:9); CV_i_df[,1] <- as.factor(areaNum)

for(i in seq_along(CV_i_list)) {
  CV_i_df[i,2] <- data.frame(as.data.frame(CV_i_list[[i]]))
}

# plot
CV.within <- ggplot(data=CV_i_df, aes(x=areaNum, y = CV_i)) + 
  geom_point(aes(y = CV_i), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black")) +
  
  scale_x_continuous(breaks = c(1:9)) +
  
  labs(x = "Area", y = "CV_i")

CV.within
```


###Alpha variability (temporal variability at the local scale (NB weighed for local community biomass)):
```{r}
alpha_CV
```


### Spatial synchrony:
```{r}
rho
```


### Within-patch variance (ie temporal variance of each local area's total community CPUE, within local communities):
```{r}
w_ii
```


### Temporal covariance of total community CPUE between all pairs of local communities. Broadly speaking, local areas 1-6 covary positively with eachother, as do areas 7-9. Areas 1-6 covary negatively with 7-9.
```{r}
w_ih
```


###Beta variability (Multiplicative beta variability, i.e. the degree of spatial asynchrony):
```{r}
Beta1
```


###Gamma variability (temporal variability at the metacommunity scale):
```{r}
gamma_CV
```

