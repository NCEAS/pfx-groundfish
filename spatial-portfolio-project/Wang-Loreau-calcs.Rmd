---
title: "Local vs Regional Stability of Gulf of Alaksa Groundfish Assemblages"
author: "Colette Ward"
date: "July 12, 2016"
output: pdf_document
---


```{r, include=FALSE, echo=FALSE, results='hide'}
# Load packages
library(plyr)
library(dplyr)
library(tidyr)
library(vegan)
library(mvnormtest)
library(synchrony)
library(psych)
library(ggplot2)
library(gridExtra)

```


# Jump to line 803


```{r,  include=FALSE, echo=FALSE, results='hide'}

# load & prep look-up table of common names
common <- read.csv("./diversity-data/trawl_species_control_file.csv", header = T, stringsAsFactors = FALSE)

common1 <- common %>%
  select(database.name, common.name) %>%
  rename(Species = database.name)
for (i in 1:nrow(common1)) { # add common names for Sebastes 1 & 2
  if(common1$Species[i] == "Dusky.and.Dark.Rockfish") {common1$common.name[i] <- "Sebastes 1"}
  if(common1$Species[i] == "Rougheye.and.Blackspotted.Rockfish") {common1$common.name[i] <- "Sebastes 2"}
}


# load area file (km^2)
area <- read.csv("./spatial-portfolio-project/local-community-area.csv", header = T, stringsAsFactors = F) %>% # note area numbers do not need updating; they reflect removal of Ole's area 8
  filter(area != "Region") %>%
  mutate(area = as.numeric(area))

```


```{r,  include=FALSE, echo=FALSE, results='hide'}
# load & prep mean annual CPUE data for Shallow Areas:
shallowCPUEArea <- read.csv("./diversity-data/All_sp_index_meanCPUEByArea.Shallow.MH.final.csv", header = T, stringsAsFactors = FALSE) # note areas have been renumbered here


shallowCPUEArea2 <- left_join(shallowCPUEArea, common1, by = "Species") %>% # merge common names onto SPCPUEArea
  select(area, Mean.totalDensity, SD.totalDensity, year, Species, common.name) %>%
  left_join(area, by = "area") # merge in area (km^2) of each local community


```


```{r,  include=FALSE, echo=FALSE, results='hide'}
# load mean annual CPUE for Deep areas:
deepCPUEArea <- read.csv("./diversity-data/All_sp_index_meanCPUEByArea.Deep.MH.final.csv", header = T, stringsAsFactors = FALSE) # this is the latest file created by Mary Oct 26 2016

deepCPUEArea2 <- left_join(deepCPUEArea, common1, by = "Species") %>% # merge in common names
  select(area, Mean.totalDensity, SD.totalDensity, year, Species, common.name) %>%
  mutate(area = revalue(area, c("1"="11", "2"="12", "3"="14", "4"="15", "5"="13", "Total" = "Region")))  %>% # renumbering areas - check this, did Mary already renumber the areas?
  left_join(area, by = "area")

```


```{r,  include=FALSE, echo=FALSE, results='hide'}

# set working directory
setwd("~/Google Drive/GoA project/pfx-groundfish/spatial-portfolio-project")

```


```{r,  include=FALSE, echo=FALSE, results='hide'}

# Create spatially-nested groupings for shallow communities (all possible combinations of adjacent communities):

# 1 community:
a1 <- list(1)
a2 <- list(2)
a3 <- list(3)
a4 <- list(4)
a5 <- list(5)
a6 <- list(6)
a7 <- list(7)
a8 <- list(8)
a9 <- list(9)
a10 <- list(10)


# 2 communities:
b1 <- list(1:2)
b2 <- list(2:3)
b3 <- list(3:4)
b4 <- list(4:5)
b5 <- list(5:6)
b6 <- list(6:7)
b7 <- list(7:8)
b8 <- list(8:9)
b9 <- list(9:10)


# 3 communities:
c1 <- list(1:3)
c2 <- list(2:4)
c3 <- list(3:5)
c4 <- list(4:6)
c5 <- list(5:7)
c6 <- list(6:8)
c7 <- list(7:9)
c8 <- list(8:10)


# 4 communities:
d1 <- list(1:4)
d2 <- list(2:5)
d3 <- list(3:6)
d4 <- list(4:7)
d5 <- list(5:8)
d6 <- list(6:9)
d7 <- list(7:10)


# 5 communities:
e1 <- list(1:5)
e2 <- list(2:6)
e3 <- list(3:7)
e4 <- list(4:8)
e5 <- list(5:9)
e6 <- list(6:10)


# 6 communities:
f1 <- list(1:6)
f2 <- list(2:7)
f3 <- list(3:8)
f4 <- list(4:9)
f5 <- list(5:10)


# 7 communities:
g1 <- list(1:7)
g2 <- list(2:8)
g3 <- list(3:9)
g4 <- list(4:10) 


# 8 communities:
h1 <- list(1:8)
h2 <- list(2:9)
h3 <- list(3:10)


# 9 communities:
j1 <- list(1:9)
j2 <- list(2:10)


# 10 communities:
k1 <- list(1:10)


spatially_nested_list <- c(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, # 1 local community
                           b1, b2, b3, b4, b5, b6, b7, b8, b9, # 2 local communities
                           c1, c2, c3, c4, c5, c6, c7, c8, # 3
                           d1, d2, d3, d4, d5, d6, d7, # 4
                           e1, e2, e3, e4, e5, e6, # 5
                           f1, f2, f3, f4, f5, # 6
                           g1, g2, g3, g4, # 7
                           h1, h2, h3, # 8
                           j1, j2, # 9
                           k1) # 10

spatially_nested_list_noSingles <- c(b1, b2, b3, b4, b5, b6, b7, b8, b9, # 2 local communities
                                     c1, c2, c3, c4, c5, c6, c7, c8, # 3
                                     d1, d2, d3, d4, d5, d6, d7, # 4
                                     e1, e2, e3, e4, e5, e6, # 5
                                     f1, f2, f3, f4, f5, # 6
                                     g1, g2, g3, g4, # 7
                                     h1, h2, h3, # 8
                                     j1, j2, # 9
                                     k1) # 10



##################################################
##################################################
##################################################


# create 100 random draws of 2, 3, 4, ... 9 local communities

random1_list <- list()
random2_list <- list()
random3_list <- list()
random4_list <- list()
random5_list <- list()
random6_list <- list()
random7_list <- list()
random8_list <- list()
random9_list <- list()

for (i in 1:100) {
  random1_list[[i]] <- sample(seq(1:10), size = 1)
  random2_list[[i]] <- sample(seq(1:10), size = 2)
  random3_list[[i]] <- sample(seq(1:10), size = 3)
  random4_list[[i]] <- sample(seq(1:10), size = 4)
  random5_list[[i]] <- sample(seq(1:10), size = 5)
  random6_list[[i]] <- sample(seq(1:10), size = 6)
  random7_list[[i]] <- sample(seq(1:10), size = 7)
  random8_list[[i]] <- sample(seq(1:10), size = 8)
  random9_list[[i]] <- sample(seq(1:10), size = 9)
}
random10_list <- list(1:10)

random_agg_list <- c(random1_list, random2_list, random3_list, random4_list, random5_list, random6_list, random7_list, random8_list, random9_list, random10_list)
#save(random_agg_list, file = "random_agg_list.RData")
load("random_agg_list.RData")

random_agg_list_noSingles <- c(random2_list, random3_list, random4_list, random5_list, random6_list, random7_list, random8_list, random9_list, random10_list)
#save(random_agg_list_noSingles, file = "random_agg_list_noSingles.RData")
load("random_agg_list_noSingles.RData")


```



```{r, echo=FALSE}

# Calculate CV & Area (km^2)

CV_Area_func <- function(my_df, spatialGrouping){
  
  CV_agg_list <- list()
  Area_agg_list <- list()
  n_list <- list()
  df_list <- list()
  
  for(i in seq_along(spatialGrouping)) {
  
                CV_agg_list[[i]] <- my_df %>%
                          filter(area %in% spatialGrouping[[i]]) %>%
                          group_by(year) %>%
                          summarise(total = sum(Mean.totalDensity)) %>%
                          ungroup() %>%
                          summarise(CV = sd(total) / mean(total))
  
                Area_agg_list[[i]] <- my_df %>%
                            filter(area %in% spatialGrouping[[i]]) %>%
                            select(area, km2) %>%
                            group_by(area) %>%
                            summarise(eachArea = first(km2)) %>%
                            ungroup() %>%
                            summarise(area_agg = sum(eachArea))
                
                
                # record the number of local communities in the aggregation
                n_list[[i]] <- length(spatialGrouping[[i]])
  }
  
  df_list <- list(n_list, Area_agg_list, CV_agg_list)
  my_df <- as.data.frame(matrix(unlist(df_list), nrow=length(unlist(df_list[1]))))
  colnames(my_df) <- c("n", "Area", "CV")
  my_df <- mutate(my_df, id = rownames(my_df)) # add column with unique number
  
  return(my_df)
  
}


# run function for spatially nested aggregations of local communities:
CV_Area_spatNested <- CV_Area_func(shallowCPUEArea2, spatially_nested_list_noSingles)


# run function for random aggregations of local communities:
CV_Area_randomAgg <- CV_Area_func(shallowCPUEArea2, random_agg_list_noSingles)
#save(CV_Area_randomAgg, file = "CV_Area_randomAgg.RData")


```




```{r, echo=FALSE, fig.height=3.5, fig.width=8}

# Calculate cumulative Species Richness

# load occurrence data
setwd("~/Google Drive/GoA project/pfx-groundfish")
occDat <-read.csv("./diversity-data/All_sp_index_occurrenceByArea.Shallow.MH.final.csv", header = T, stringsAsFactors = FALSE)

setwd("~/Google Drive/GoA project/pfx-groundfish/spatial-portfolio-project")


occDat1 <- occDat %>%
  select(area, year.numb, Species, Mean.avgPresence)



Richness_func <- function(my_df, spatialGrouping){
  
  richness_agg_list <- list()
  
  
  for(j in 1:length(spatialGrouping)) {
    
    richness_agg_list[[j]] <- my_df %>%
                   filter(area %in% spatialGrouping[[j]]) %>%
                   
                   mutate(pAbsence = 1-Mean.avgPresence, # for each species in each year and in each patch, calculate probability of species absence
                          year.numb = as.character(year.numb)) %>%
                   
                   group_by(year.numb, Species) %>%
                   summarize(probAbsenceAll = prod(pAbsence)) %>% # for each species in each year, calculate probability of species absence from ALL sites
                   ungroup() %>%
      
                   mutate(probAtLeastOnePresence = 1-probAbsenceAll) %>% # for each species in each year, calculate probability of presence in AT LEAST one patch
      
                   group_by(year.numb) %>%
                   summarize(annSpRich = sum(probAtLeastOnePresence)) %>% # calculate species richness for each year
                   ungroup() %>%
      
                   summarize(meanSpRich = mean(annSpRich)) # calculate mean Species Richness across all years for aggregation j
                    
    
    } # end of j
  
  df_list <- list(richness_agg_list)
  spRichness_df <- as.data.frame(matrix(unlist(df_list), nrow=length(unlist(df_list[1]))))
  colnames(spRichness_df) <- c("regionalSpRichness")
  spRichness_df <- mutate(spRichness_df, id = rownames(spRichness_df)) # add column with unique number
  
  return(spRichness_df)
  
  }


# run function for spatially nested aggregations of local communities:
richness_spatNested <- Richness_func(occDat1, spatially_nested_list_noSingles)
#richness_spatNested_withSingles <- Richness_func(occDat1, spatially_nested_list); richness_spatNested_withSingles

# run function for random aggregations of local communities:
richness_randomAgg <- Richness_func(occDat1, random_agg_list_noSingles)
#save(richness_randomAgg, file = "richness_randomAgg.RData")


```


``` {r, echo = FALSE}

# Calculate alpha diversity (at the aggregated regional scale)

alphaDiv_func <- function(my_df, spatialGrouping){
  
  alpha_list <- list()
  
  for(j in 1:length(spatialGrouping)) {
  
    alpha_list[[j]] <- my_df %>%
                   filter(area %in% spatialGrouping[[j]]) %>%
    
      
    group_by(year, Species) %>%  
    summarize(totDensity = sum(Mean.totalDensity)) %>% # consider whether to take summed or mean abundance across all patches in the aggregation
    ungroup() %>%
    
    
    group_by(year) %>%
    summarize(SW_Div = diversity(totDensity, index="shannon"), 
              Exp_A_Div = exp(SW_Div)) %>% # calculate alpha for each year ... should this be calculated on raw or log abundances???
    ungroup() %>% # note between-year variation in Exp_A_Div
    
    summarize(meanExp_A_Div = mean(Exp_A_Div)) # calculate mean alpha across all years
    
  }
  
  
  df_list <- list(alpha_list)
  alpha_df <- as.data.frame(matrix(unlist(df_list), nrow=length(unlist(df_list[1]))))
  colnames(alpha_df) <- c("regionalExpAlpha")
  alpha_df <- mutate(alpha_df, id = rownames(alpha_df)) # add column with unique number
  
  return(alpha_df)
  
}


# run for spatially-nested aggregations of local communities:
alphaDiv_spatNested <- alphaDiv_func(shallowCPUEArea2, spatially_nested_list_noSingles)

# run for random aggregations of local communities:
alphaDiv_randomAgg <- alphaDiv_func(shallowCPUEArea2, random_agg_list_noSingles)
#save(alphaDiv_randomAgg, file = "alphaDiv_randomAgg.RData")

```


```{r, echo=FALSE, fig.height=5, fig.width=5}

# Calculate local asynchrony within sites (species-level)
sync_within_func <- function(my_df, spatialGrouping){
  
  AA_list <- list()
  loreau_means_list <- list()
  gross_means_list <- list()
  thibaut_means_list <- list()
  
  
  # create nested lists with 2 levels:
  AAA_list <- vector("list", length(spatialGrouping))
  loreau_list <- vector("list", length(spatialGrouping))
  gross_list <- vector("list", length(spatialGrouping))
  AAAA_list <- vector("list", length(spatialGrouping))
  rMean_list <- vector("list", length(spatialGrouping))
  thibaut_list <- vector("list", length(spatialGrouping))
  
    
  for(j in 1:length(spatialGrouping)) {
    
    AA_list[[j]] <- my_df %>%
                    filter(area %in% spatialGrouping[[j]]) 
    # NOTE THAT AA_list IS NEVER USED BELOW ... ???
  
      
    for(k in 1:length(spatialGrouping[[j]])) {
      
      AAA_list[[j]][[k]] <- my_df %>%
                            filter(area %in% spatialGrouping[[j]]) %>%
                            filter(area == spatialGrouping[[j]][k]) #%>%
         
                            #select(year, common.name, Mean.totalDensity) %>%
                            #group_by(year, common.name) %>%
                            #summarize(totDensity = sum(Mean.totalDensity)) %>% # for each species in each year, sum its total density ... this does nothing, as everything is already summarized by year & common.name
                            #ungroup()
                
      
   ###################### 
      
      # Loreau & de Mazancourt 2008 metric:
      # *********** NOT independent of stability **********
      # "This measure of synchrony is standardized between 0 (perfect asynchrony) and 1 (perfect synchrony).
      # it will return similar values for communities shaped by different processes – for example, even if 
      # species vary independently, the synchrony metric may be affected by the number of species and individual species variances."
      # "The Loreau method is based on variances, and is therefore more heavily influenced by abundant species."
      loreau_list[[j]][[k]] <- codyn::synchrony(AAA_list[[j]][[k]], 
                                         time.var = "year", 
                                         species.var = "common.name", 
                                         abundance.var = "Mean.totalDensity", 
                                         metric = "Loreau")
      
      # Gross et al. 2014 metric:  
      # mean synchrony = mean correlation coefficient r between the abundances A_i of each species i 
      # versus the rest of the community (all A_j except i)
      # syn = 1/S * sum(cor(A_i, sum(A_j excluding i)))
      # where S = number of species
      # "This measure of synchrony is standardized from -1 (perfect asynchrony) to 1 (perfect synchrony) 
      # and is centered at 0 when species fluctuate independently. A virtue of this metric is it is 
      # not sensitive to richness and has the potential for null-model significance testing."
      # "... the Gross method is based on correlation and consequently weights species equally."
      gross_list[[j]][[k]] <- codyn::synchrony(AAA_list[[j]][[k]], 
                                         time.var = "year", 
                                         species.var = "common.name", 
                                         abundance.var = "Mean.totalDensity", 
                                         metric = "Gross")     
 
      
      # Thibaut & Connolly 2013 metric:
      #rho <- ((1 - mean r_ij) / S) + mean r_ij
      # where mean r_ij = arithmetic mean correlation coefficient across all species pairs
      # perfect asynchrony: rho = 0; synchrony: rho = 1
      AAAA_list[[j]][[k]] <- AAA_list[[j]][[k]] %>%
                             spread(common.name, Mean.totalDensity) %>%
                             select(-year)
      # note there are many NAs in each df after this step; only some fish species have some numbers

      
      rMean_list[[j]][[k]] <- synchrony::meancorr(AAAA_list[[j]][[k]])$obs
      thibaut_list[[j]][[k]] <- ((1-rMean_list[[j]][[k]]) / ncol(AAAA_list[[j]][[k]])) + rMean_list[[j]][[k]]
      
      
    } # end of k
    
    
  } # end of j
  
  return(thibaut_list)
  
}  

      # sum [[j]] over all [[j]][[k]]
      loreau_means_list[[j]] <- mean(loreau_list[[j]][[k]])
      
      gross_means_list[[j]] <- mean(gross_list[[j]][[k]])
      
      thibaut_means_list[[j]] <- mean(thibaut_list[[j]][[k]])
      
      
    } # end of k
    
    
  } # end of j
  
  ###################### 

  # return dataframe of outputs
  
  syn_list <- list(loreau_means_list, gross_means_list, thibaut_means_list)
  syn_df <- as.data.frame(matrix(unlist(syn_list), nrow=length(unlist(syn_list[1]))))
  colnames(syn_df) <- c("loreauSyncWithin", "grossSyncWithin", "thibautSyncWithin")
  syn_df <- mutate(syn_df, id = rownames(syn_df)) # add column with unique number
  
  return(syn_df)
  
}    
      

# run for spatially-nested aggregations of local communities:
sync_within_spatNested <- sync_within_func(shallowCPUEArea2, spatially_nested_list_noSingles)
sync_within_spatNested[[1]][[1]]

# run for random aggregations of local communities:
sync_within_randomAgg <- sync_within_func(shallowCPUEArea2, random_agg_list_noSingles)
#save(sync_within_randomAgg, file = "sync_within_randomAgg.RData")


```


``` {r, echo = FALSE}

# Calculate biomass uneveness between patches
# (mean between-patch difference in total CPUE)


spat_uneveness_func <- function(my_df, spatialGrouping){
  
  unlisted_list <- list()
  diffs_list <- list()
  mean_pairwise_diffs_list <- list()
  
  # create nested lists with 2 levels:
  indivCPUE_list <- vector("list", length(spatialGrouping))
  
  
  for(j in 1:length(spatialGrouping)) {
    
    
    for(k in 1:length(spatialGrouping[[j]])) {
      
      # for each individual patch within the aggregation, calculate mean annual CPUE (all species summed)
      indivCPUE_list[[j]][[k]] <- my_df %>%
                                  filter(area %in% spatialGrouping[[j]]) %>%
                                  filter(area == spatialGrouping[[j]][k]) %>%
        
                                  group_by(year) %>%
                                  summarize(annCPUE = sum(Mean.totalDensity)) %>%
                                  ungroup() %>%
                                  summarize(meanAnnCPUE = mean(annCPUE))
    
    } # end of k
    
    
    unlisted_list[[j]] <- unlist(indivCPUE_list[[j]]) # flatten each j list to a vector
    diffs_list[[j]] <- abs(apply(combn(unlisted_list[[j]], 2), 2, diff)) # for each pair of patches within the aggregation (excluding self pairs), calculate the pairwise difference in total CPUE (absolute value)
    mean_pairwise_diffs_list[[j]] <- mean(diffs_list[[j]]) # for each aggregation, calculate mean of all pairwise differences
    
    
  } # end of j
  
  
  # return dataframe of outputs:
  unev_list <- list(mean_pairwise_diffs_list)
  unev_df <- as.data.frame(matrix(unlist(unev_list), nrow=length(unlist(unev_list[1]))))
  colnames(unev_df) <- c("meanUnevenessCPUE")
  unev_df <- mutate(unev_df, id = rownames(unev_df)) # add column with unique number
  
}
  

# run for spatially-nested aggregations of local communities:
uneveness_spatNested <- spat_uneveness_func(shallowCPUEArea2, spatially_nested_list_noSingles)

# run for random aggregations of local communities:
uneveness_randomAgg <- spat_uneveness_func(shallowCPUEArea2, random_agg_list_noSingles)
#save(uneveness_randomAgg, file = "uneveness_randomAgg.RData")


```


```{r, echo=FALSE, fig.height=5, fig.width=5}

# Synchrony between local communities (total community-level)

sync_between_func <- function(my_df, spatialGrouping){
  
  BB_list <- list()
  BBB_list <- list(); loreau_list <- list(); gross_list <- list()
  BBBB_list <- list(); rMean_list <- list(); thibaut_list <- list()
  
    
  for(j in 1:length(spatialGrouping)) {
    
    BB_list[[j]] <- my_df %>%
                    filter(area %in% spatialGrouping[[j]])
  
    
    BBB_list[[j]] <- BB_list[[j]] %>%
                     select(area, year, common.name, Mean.totalDensity) %>%
                     group_by(area, year) %>%
                     summarize(totDensity = sum(Mean.totalDensity)) %>% # for aggregated community in each year, sum total density across all species
                     ungroup()
        
    
    
    # Loreau & de Mazancourt 2008 metric:
    loreau_list[[j]] <- codyn::synchrony(BBB_list[[j]], 
                                         time.var = "year", 
                                         species.var = "area", 
                                         abundance.var = "totDensity", 
                                         metric = "Loreau")
    
    
  
    # Gross et al. 2014 metric:  
    gross_list[[j]] <- codyn::synchrony(BBB_list[[j]], 
                                        time.var = "year", 
                                        species.var = "area", 
                                        abundance.var = "totDensity", 
                                        metric = "Gross")
  
      
    
    # Thibaut & Connolly 2013 metric:
    BBBB_list[[j]] <- BBB_list[[j]] %>%
                      spread(area, totDensity) %>%
                      select(-year)
    rMean_list[[j]] <- synchrony::meancorr(BBBB_list[[j]])$obs
    thibaut_list[[j]] <- ((1-rMean_list[[j]]) / ncol(BBBB_list[[j]])) + rMean_list[[j]]
    
    
    
    } # end of j
  
    ###################### 
  
  # return dataframe of outputs
  
  syn_list <- list(loreau_list, gross_list, thibaut_list)
  syn_df <- as.data.frame(matrix(unlist(syn_list), nrow=length(unlist(syn_list[1]))))
  colnames(syn_df) <- c("loreauSyncBetween", "grossSyncBetween", "thibautSyncBetween")
  syn_df <- mutate(syn_df, id = rownames(syn_df)) # add column with unique number
  
  return(syn_df)
  
}


# run function for spatially-nested aggregations of local communities:
# note I must remove single local communities to look at synchrony between communities
sync_between_spatNested <- sync_between_func(shallowCPUEArea2, spatially_nested_list_noSingles)


# run function for random aggregations of local communities:
# note I must remove single local communities to look at synchrony between communities
sync_between_randomAgg <- sync_between_func(shallowCPUEArea2, random_agg_list_noSingles)
#save(sync_between_randomAgg, file = "sync_between_randomAgg.RData")

```



```{r,  include=FALSE, echo=FALSE, results='hide'}

# Wang & Loreau's average species variability (within-patch):

avSpeciesVar_within_func <- function(my_df, spatialGrouping){
  
  AA_list <- list()
  AAA_list <- list()
  A_list <- list(); B_list <- list(); C_list <- list()
  
    
  for(j in 1:length(spatialGrouping)) {
    
    AA_list[[j]] <- my_df %>%
                    filter(area %in% spatialGrouping[[j]]) 
    
    AAA_list[[j]] <- AA_list[[j]] %>%
                     select(year, common.name, Mean.totalDensity) %>%
                     group_by(year, common.name) %>%
                     summarize(spTotDensity = sum(Mean.totalDensity)) %>% # for each species in each year, sum its total density across all local communities in the spatial grouping
                     ungroup()
        
    
    
    #Calculate averaged species variability (C_list$CV_species_i_squared):
  
    # calculate local community-level stuff
    A_list[[j]] <- AAA_list[[j]] %>%
      group_by(year) %>%
      summarize(annual_total_i = sum(spTotDensity)) %>% # sum CUEs across all species for each local community i in each year
      ungroup() %>%
      summarize(var_i = var(annual_total_i),
                stDev_i = sqrt(var(annual_total_i)),
                u_i = mean(annual_total_i)) # mean total community CUE (across all years) for local community (or spatial grouping) i
    
    
  # calculate species-level stuff
    B_list[[j]] <- AAA_list[[j]] %>%
      group_by(common.name) %>%
      summarize(u_j_i = mean(spTotDensity), # mean CUE (across all years) of species j in local community (or spatial grouping) i
                CV_j_i_squared = sqrt(var(spTotDensity)) / u_j_i, # CV of species j in local community i; CV = StDev / Mean
                CV_species_j_i = u_j_i / A_list[[j]]$u_i * CV_j_i_squared) %>% # CV of species j in local community i, weighted for percent contribution of each species' abundance to total abundance of local community (or spatial grouping)
      ungroup()
    
    
  # calculate averaged species variability
    C_list[[j]] <- B_list[[j]] %>%
      summarise(CV_species_i_squared = sum(CV_species_j_i))
    
    
  }

  
  avSpVar_list <- list(C_list)
  avSpVar_df <- as.data.frame(matrix(unlist(avSpVar_list), nrow=length(unlist(avSpVar_list[1]))))
  colnames(avSpVar_df) <- c("avSpVar")
  avSpVar_df <- mutate(avSpVar_df, id = rownames(avSpVar_df)) # add column with unique number
  
  return(avSpVar_df)

}



# run function for spatially-nested aggregations of local communities:
avSpVar_within_spatNested <- avSpeciesVar_within_func(shallowCPUEArea2, spatially_nested_list_noSingles)

# run function for random aggregations of local communities:
avSpVar_within_randomAgg <- avSpeciesVar_within_func(shallowCPUEArea2, random_agg_list_noSingles)
#save(avSpVar_within_randomAgg, file = "avSpVar_within_randomAgg.RData")

```


```{r,  echo=FALSE, fig.height=4, fig.width=5}

# Effect of spatial turnover in community composition on stability

bray_func <- function(your_df, spatialGrouping){
  
  # create flat lists:
  pair_list <- list()
  wisc_list <- list()
  bray_list <- list()
  
  
  # create nested lists with 2 levels:
  subpair_list <- vector("list", length(spatialGrouping))
  subpair_df_list <- vector("list", length(spatialGrouping)) 
  
  
  ##############################
  
  # 1. Loop over list of j pairs to create pairs for Bray matrix
    
  for(j in 1:length(spatialGrouping)) { # ie for each of 801 elements in myNums_agg_list_noSingles
    
    # split each spatialGrouping in half:
    subpair_list[[j]][[1]] <- spatialGrouping[[j]][1 : (ceiling(length(spatialGrouping[[j]])/2)) ]
    subpair_list[[j]][[2]] <- spatialGrouping[[j]][ ((ceiling(length(spatialGrouping[[j]])/2))+1) : length(spatialGrouping[[j]])]
    
    
    # now loop over subpair_list
    subpair_df_list[[j]][[1]] <- your_df %>%
                                filter(area %in% subpair_list[[j]][[1]]) %>%
                                select(common.name, Mean.totalDensity, area, year) %>%
                                group_by(common.name) %>%
                                summarize(temporal.mean = mean(Mean.totalDensity)) %>%
                                ungroup() %>%
                                spread(common.name, temporal.mean)
    
     subpair_df_list[[j]][[2]] <- your_df %>%
                                filter(area %in% subpair_list[[j]][[2]]) %>%
                                select(common.name, Mean.totalDensity, area, year) %>%
                                group_by(common.name) %>%
                                summarize(temporal.mean = mean(Mean.totalDensity)) %>%
                                ungroup() %>%
                                spread(common.name, temporal.mean)
     
     ##############################
    
    # 2. Calculate Bray dissimilarities
    
    pair_list[[j]] <- bind_rows(subpair_df_list[[j]]) # bind dfs in subpair_list with the same j
    wisc_list[[j]] <- wisconsin(pair_list[[j]]) # Wisconsin transformation. Consider also wisconsin(sqrt(x)). Check that I'm combining these in the right way.
    bray_list[[j]] <- vegdist(wisc_list[[j]], "bray") # calculate Bray-Curtis dissimilarities for each j pair of k local communities
    
      
    } # end of j
  
  
    ##############################
  
    # 5. Return dataframe of outputs
  
    my_list <- list(bray_list)
    bray_df <- as.data.frame(matrix(unlist(my_list), nrow=length(unlist(my_list[1]))))
    colnames(bray_df) <- c("bray")
    bray_df <- mutate(bray_df, id = rownames(bray_df)) # add column with unique number
    
    return(bray_df)
    
  
}


# run function for spatially-nested aggregations of local communities:
brayResult_spatNested <- bray_func(shallowCPUEArea2, spatially_nested_list_noSingles)

# run function for random aggregations of local communities:
brayResult_randomAgg <- bray_func(shallowCPUEArea2, random_agg_list_noSingles)
#save(brayResult_randomAgg, file = "brayResult_randomAgg.RData")



################


# alternate function for Bray dissimilarity (mean of all pairwise dissimilarities, intead of splitting dataset in 2 groups and taking dissimilarity between 2 mean communities, as above):

alt_bray_func <- function(your_df, spatialGrouping){
  
  agg_list <- list()
  wisc_list <- list()
  bray_list <- list()
  mean_bray_list <- list()
  
  # create nested lists with 2 levels:
  patch_list <- vector("list", length(spatialGrouping))
  
  
    for(j in 1:length(spatialGrouping)) {
            

      for(k in 1:length(spatialGrouping[[j]])) {
        
        
        # prep data for Bray:
        patch_list[[j]][[k]] <- your_df %>%
                                filter(area %in% spatialGrouping[[j]]) %>%
                                filter(area == spatialGrouping[[j]][k]) %>%
        
                                select(common.name, Mean.totalDensity, area, year) %>%
                                group_by(common.name) %>%
                                summarize(temporal.mean = mean(Mean.totalDensity)) %>% # mean annual density of each species
                                ungroup() %>%
                                spread(common.name, temporal.mean)
        
      } # end of k
      
      
      agg_list[[j]] <- bind_rows(patch_list[[j]]) # bind dfs in patch_list with the same j
      wisc_list[[j]] <- wisconsin(agg_list[[j]]) # Wisconsin transformation. Consider also wisconsin(sqrt(x)). Check that I'm combining these in the right way.
      bray_list[[j]] <- vegdist(wisc_list[[j]], "bray") # calculate Bray-Curtis dissimilarities for all pairs of k patches within each aggregation j
      mean_bray_list[[j]] <- mean(bray_list[[j]]) # calculate mean dissimilarity between all k patches in aggregation j
      
    } # end of j

  
  my_list <- list(mean_bray_list)
  bray_df <- as.data.frame(matrix(unlist(my_list), nrow=length(unlist(my_list[1]))))
  # returns df with 2 columns
  colnames(bray_df) <- c("meanBray")
  bray_df <- mutate(bray_df, id = rownames(bray_df)) # add column with unique number
    
  return(bray_df)
  
}


# run function for spatially-nested aggregations of local communities:
altBrayResult_spatNested <- alt_bray_func(shallowCPUEArea2, spatially_nested_list_noSingles)

# run function for random aggregations of local communities:
altBrayResult_randomAgg <- alt_bray_func(shallowCPUEArea2, random_agg_list_noSingles)
#save(altBrayResult_randomAgg, file = "altBrayResult_randomAgg.RData")


```


``` {r, echo=FALSE}

# bind dataframes together

randomAgg <- CV_Area_randomAgg %>%
  left_join(richness_randomAgg, by = "id") %>%
  left_join(alphaDiv_randomAgg, by = "id") %>%
  left_join(sync_within_randomAgg, by = "id") %>%
  left_join(sync_between_randomAgg, by = "id") %>%
  left_join(avSpVar_within_randomAgg, by = "id") %>%
  left_join(uneveness_randomAgg, by = "id") %>%
  #left_join(brayResult_randomAgg, by = "id") %>%
  left_join(altBrayResult_randomAgg, by = "id") %>%
  mutate(n = as.character(n))
#save(randomAgg, file = "randomAgg.RData")


spatNested <- CV_Area_spatNested %>%
  left_join(richness_spatNested, by = "id") %>%
  left_join(alphaDiv_spatNested, by = "id") %>%
  left_join(sync_within_spatNested, by = "id") %>%
  left_join(sync_between_spatNested, by = "id") %>%
  left_join(avSpVar_within_spatNested, by = "id") %>%
  left_join(uneveness_spatNested, by = "id") %>%
  #left_join(brayResult_spatNested, by = "id") %>%
  left_join(altBrayResult_spatNested, by = "id") %>%
  mutate(n = as.character(n))
#save(spatNested, file = "spatNested.RData")


```


``` {r, echo = FALSE}

setwd("~/Google Drive/GoA project/pfx-groundfish/spatial-portfolio-project")

load("randomAgg.RData")
load("spatNested.RData")

```


Look at correlation structure between independent variables
``` {r, echo=FALSE, fig.height=3.5, fig.width=8}

spatNested_indepVar <- spatNested %>%
  select(Area, grossSyncWithin, grossSyncBetween, avSpVar, bray)
pairs.panels(spatNested_indepVar,smooth=F,density=T,ellipses=F,lm=T,digits=3,scale=T, cor = T, rug=T, main = "Spatially Nested Aggregations of Local Communities")
# REMEMBER TO INVERT SYNCHRONY METRICS BEFORE DRAWING CONCLUSIONS ABOUT CORRELATIONS WITH OTHER VARIABLES


randomAgg_indepVar <- randomAgg %>%
  select(Area, grossSyncWithin, grossSyncBetween, avSpVar, bray)
pairs.panels(randomAgg_indepVar,smooth=F,density=T,ellipses=F,lm=T,digits=3,scale=T, cor = T, rug=T, main = "Random Aggregations of Local Communities")



############################################
############################################
############################################


# Look at correlations by number of local communities in the aggregation:

# 1. Create categories for plotting by number of local communities in the aggregation:
colorsN <- c("red", "orange", "yellow3", "green", "blue", "purple", "brown", "black", "grey")
shapesN <- rep(16, 9)
catN <- c("2", "3", "4", "5", "6", "7", "8", "9", "10")


# create plot themes
theme_1_withLegend <- function(base_size = 12){
  theme_bw(base_size)%+replace%
    theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=10), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=10),
        axis.title.x=element_text(size=12, margin=margin(7,0,0,0)),
        axis.title.y=element_text(size=12, angle=90, margin=margin(0,7,0,0)),
        plot.title = element_text(size=14))
}


theme_1_noLegend <- function(base_size = 12){
  theme_bw(base_size)%+replace%
    theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=10), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=10),
        axis.title.x=element_text(size=12, margin=margin(7,0,0,0)),
        axis.title.y=element_text(size=12, angle=90, margin=margin(0,7,0,0)),
        plot.title = element_text(size=14),
        legend.position="none")
}



# Spatially-nested aggregations of local communities:
# grossSyncWithin, grossSyncBetween 
SN_cor_grossSyncWithin_Between <- ggplot(data=spatNested, aes(x=grossSyncWithin, y = grossSyncBetween, color = n, shape = n)) + 
  geom_point(size=3, show.legend = FALSE) +
  theme_1_withLegend() +
  geom_smooth(method = lm, se = F, size = 0.75) +
  scale_color_manual(values = colorsN, limits = catN) +
  scale_shape_manual(values = shapesN, limits = catN) +
  labs(x = "Gross Asynchrony
       (within-patch, between species)",
       y = "Gross Asynchrony
       (between-patch)")


# grossSyncWithin, avSpVar
SN_cor_grossSyncWithin_avSpVar <- ggplot(data=spatNested, aes(x=grossSyncWithin, y = avSpVar, color = n, shape = n)) + 
  geom_point(size=3, show.legend = FALSE) +
  theme_1_noLegend() +
  geom_smooth(method = lm, se = F, size = 1) +
  scale_color_manual(values = colorsN, limits = catN) +
  scale_shape_manual(values = shapesN, limits = catN) +
  labs(x = "Gross Asynchrony
       (within-patch, between species)",
       y = "Mean Species Variability (within-patch)")


# grossSyncWithin, bray
SN_cor_grossSyncWithin_bray <- ggplot(data=spatNested, aes(x=grossSyncWithin, y = bray, color = n, shape = n)) + 
  geom_point(size=3, show.legend = FALSE) +
  theme_1_noLegend() +
  geom_smooth(method = lm, se = F, size = 1) +
  scale_color_manual(values = colorsN, limits = catN) +
  scale_shape_manual(values = shapesN, limits = catN) +
  labs(x = "Gross Asynchrony
       (within-patch, between species)",
       y = "Bray Dissimilarity")

#grossSyncBetween, avSpVar
SN_cor_grossSyncBetween_avSpVar <- ggplot(data=spatNested, aes(x=grossSyncBetween, y = avSpVar, color = n, shape = n)) + 
  geom_point(size=3, show.legend = FALSE) +
  theme_1_noLegend() +
  geom_smooth(method = lm, se = F, size = 1) +
  scale_color_manual(values = colorsN, limits = catN) +
  scale_shape_manual(values = shapesN, limits = catN) +
  labs(x = "Gross Asynchrony
       (between-patch)",
       y = "Mean Species Variability (within-patch)")
cor.test(spatNested$grossSyncBetween, spatNested$avSpVar)
# p = 0.03, r = 0.32


#grossSyncBetween, bray
SN_cor_grossSyncBetween_bray <- ggplot(data=spatNested, aes(x=grossSyncBetween, y = bray, color = n, shape = n)) + 
  geom_point(size=3, show.legend = FALSE) +
  theme_1_noLegend() +
  geom_smooth(method = lm, se = F, size = 1) +
  scale_color_manual(values = colorsN, limits = catN) +
  scale_shape_manual(values = shapesN, limits = catN) +
  labs(x = "Gross Asynchrony
       (between-patch)",
       y = "Bray Dissimilarity")


#avSpVar, bray
SN_cor_avSpVar_bray <- ggplot(data=spatNested, aes(x=avSpVar, y = bray, color = n, shape = n)) + 
  geom_point(size=3, show.legend = FALSE) +
  theme_1_noLegend()+
  geom_smooth(method = lm, se = F, size = 1) +
  scale_color_manual(values = colorsN, limits = catN) +
  scale_shape_manual(values = shapesN, limits = catN) +
  labs(x = "Mean Species Variability (within-patch)",
       y = "Bray Dissimilarity")


grid.arrange(SN_cor_grossSyncWithin_Between, SN_cor_grossSyncWithin_avSpVar, SN_cor_grossSyncWithin_bray, SN_cor_grossSyncBetween_avSpVar, SN_cor_grossSyncBetween_bray, SN_cor_avSpVar_bray, ncol=3)



############################################

# Random aggregations of local communities:

# grossSyncWithin, grossSyncBetween 
RA_cor_grossSyncWithin_Between <- ggplot(data=randomAgg, aes(x=grossSyncWithin, y = grossSyncBetween, color = n, shape = n)) + 
  geom_point(size=2, show.legend = FALSE) +
  theme_1_withLegend() +
  geom_smooth(method = lm, se = F, size = 1) +
  scale_color_manual(values = colorsN, limits = catN) +
  scale_shape_manual(values = shapesN, limits = catN) +
  labs(x = "Gross Asynchrony
       (within-patch, between species)",
       y = "Gross Asynchrony
       (between-patch)")



# grossSyncWithin, avSpVar
RA_cor_grossSyncWithin_avSpVar <- ggplot(data=randomAgg, aes(x=grossSyncWithin, y = avSpVar, color = n, shape = n)) + 
  geom_point(size=2, show.legend = FALSE) +
  theme_1_noLegend() +
  geom_smooth(method = lm, se = F, size = 1) +
  scale_color_manual(values = colorsN, limits = catN) +
  scale_shape_manual(values = shapesN, limits = catN) +
  labs(x = "Gross Asynchrony
       (within-patch, between species)",
       y = "Mean Species Variability (within-patch)")


# grossSyncWithin, bray
RA_cor_grossSyncWithin_bray <- ggplot(data=randomAgg, aes(x=grossSyncWithin, y = bray, color = n, shape = n)) + 
  geom_point(size=2, show.legend = FALSE) +
  theme_1_noLegend() +
  geom_smooth(method = lm, se = F, size = 1) +
  scale_color_manual(values = colorsN, limits = catN) +
  scale_shape_manual(values = shapesN, limits = catN) +
  labs(x = "Gross Asynchrony
       (within-patch, between species)",
       y = "Bray Dissimilarity")


#grossSyncBetween, avSpVar
RA_cor_grossSyncBetween_avSpVar <- ggplot(data=randomAgg, aes(x=grossSyncBetween, y = avSpVar, color = n, shape = n)) + 
  geom_point(size=2, show.legend = FALSE) +
  theme_1_noLegend() +
  geom_smooth(method = lm, se = F, size = 1) +
  scale_color_manual(values = colorsN, limits = catN) +
  scale_shape_manual(values = shapesN, limits = catN) +
  labs(x = "Gross Asynchrony
       (between-patch)",
       y = "Mean Species Variability (within-patch)")
cor.test(randomAgg$grossSyncBetween, randomAgg$avSpVar)
# p-value = 1.267e-12, r = 0.25


#grossSyncBetween, bray
RA_cor_grossSyncBetween_bray <- ggplot(data=randomAgg, aes(x=grossSyncBetween, y = bray, color = n, shape = n)) + 
  geom_point(size=2, show.legend = FALSE) +
  theme_1_noLegend() +
  geom_smooth(method = lm, se = F, size = 1) +
  scale_color_manual(values = colorsN, limits = catN) +
  scale_shape_manual(values = shapesN, limits = catN) +
  labs(x = "Gross Asynchrony
       (between-patch)",
       y = "Bray Dissimilarity")


#avSpVar, bray
RA_cor_avSpVar_bray <- ggplot(data=randomAgg, aes(x=avSpVar, y = bray, color = n, shape = n)) + 
  geom_point(size=2, show.legend = FALSE) +
  theme_1_noLegend() +
  geom_smooth(method = lm, se = F, size = 1) +
  scale_color_manual(values = colorsN, limits = catN) +
  scale_shape_manual(values = shapesN, limits = catN) +
  labs(x = "Mean Species Variability (within-patch)",
       y = "Bray Dissimilarity")


grid.arrange(RA_cor_grossSyncWithin_Between, RA_cor_grossSyncWithin_avSpVar, RA_cor_grossSyncWithin_bray, RA_cor_grossSyncBetween_avSpVar, RA_cor_grossSyncBetween_bray, RA_cor_avSpVar_bray, ncol=3)


```


Plot 'Regional' CV vs Hypothesized drivers of CV
``` {r, echo=FALSE, fig.height=3.5, fig.width=8}


# 1. Create categories for plotting by number of local communities in the aggregation:
colorsN <- c("red", "orange", "yellow3", "green", "blue", "purple", "brown", "black", "grey")
shapesN <- rep(16, 9)
catN <- c("2", "3", "4", "5", "6", "7", "8", "9", "10")


############################################


# 2. Spatially Nested Aggregations:

# plot CV vs synchrony within local communities (between species)
SN_cvGross_within <- ggplot(data=spatNested, aes(x=grossSyncWithin, y = CV, color = n, shape = n)) + 
  geom_point(size=3, show.legend = FALSE) +
  theme_1_withLegend() +
  scale_x_reverse(breaks = c(0.05, 0.0, -0.05, -0.1, -0.15), labels = c(0.05, 0.0, -0.05, -0.1, -0.15)) +
  geom_smooth(method = lm, se = F, size = 0.75) +
  scale_color_manual(values = colorsN, limits = catN) +
  scale_shape_manual(values = shapesN, limits = catN) +
  labs(x = "Gross Asynchrony
       (within-patch, between species)",
       y = "CV (Total Community CUE)")




# plot CV vs synchrony between local communities
SN_cvGross_between <- ggplot(data=spatNested, aes(x=grossSyncBetween, y = CV, color = n, shape = n)) + 
  geom_point(size=3) +
  theme_1_noLegend() +
  scale_x_reverse() +
  geom_smooth(method = lm, se = F, size = 0.75) +
  scale_color_manual(values = colorsN, limits = catN) +
  scale_shape_manual(values = shapesN, limits = catN) +
  labs(x = "Gross Asynchrony (between-patch)",
       y = "CV (Total Community CUE)")



# plot CV vs average species variation (within patches)
SN_cv_AvSpVar_within <- ggplot(data=spatNested, aes(x=avSpVar, y = CV, color = n, shape = n)) + 
  geom_point(size=3) +
  theme_1_noLegend() +
  geom_smooth(method = lm, se = F, size = 0.75) +
  scale_color_manual(values = colorsN, limits = catN) +
  scale_shape_manual(values = shapesN, limits = catN) +
  labs(x = "Mean Species Variability (Within-Patch)",
       y = "CV (Total Community CUE)")




# CV vs Spatial Turnover:
SN_CV_bray_plot <- ggplot(data=spatNested, aes(x=bray, y = CV, color = n, shape = n)) + 
  geom_point(size=3) +
  theme_1_noLegend() +
  geom_smooth(method = lm, se = F, size = 0.75) +
  scale_color_manual(values = colorsN, limits = catN) +
  scale_shape_manual(values = shapesN, limits = catN) +
  labs(x = "Bray Dissimilarity", y = "CV (Total Community CUE)")



grid.arrange(SN_cvGross_within, SN_cvGross_between, SN_cv_AvSpVar_within, SN_CV_bray_plot, ncol = 2)



############################################

# Plot other stuff:

# CV vs Area
SN_CV_Area_plot <- ggplot(data=spatNested, aes(x=Area, y = CV, color = n, shape = n)) + 
  geom_point(size=5, show.legend = FALSE) +
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=12), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=12),
        axis.title.x=element_text(size=12, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=12, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  geom_smooth(method = lm, se = F, size = 1) +
  scale_color_manual(values = colorsN, limits = catN) +
  scale_shape_manual(values = shapesN, limits = catN) +
  scale_x_log10(breaks = c(5000, 10000, 20000, 30000, 40000), labels = c(5000, 10000, 20000, 30000, 40000)) +
  geom_smooth(method = lm, se = F) +
  labs(x = "Area (km^2)", y = "CV (Total Community CUE)")



################

# Cumulative Species Richness vs Area:
SN_SpRich_Area_plot <- ggplot(data=spatNested, aes(x=Area, y = regionalSpRichness, color = n, shape = n)) + 
  geom_point(size=5, show.legend = FALSE) +
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=12), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=12),
        axis.title.x=element_text(size=14, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=14, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  geom_smooth(method = lm, se = F, size = 1) +
  scale_color_manual(values = colorsN, limits = catN) +
  scale_shape_manual(values = shapesN, limits = catN) +
  scale_x_log10(breaks = c(1000, 5000, 10000, 20000, 30000, 40000), labels = c(1000, 5000, 10000, 20000, 30000, 40000)) +
  labs(x = "Area (km^2)", 
       y = "Species Richness
       (Probability of occurrence in at least one patch)", 
       main = "Random Aggregations of Local Communities")


################

# Cumulative Species Richness vs CV:
SN_CV_SpRich <- ggplot(data=spatNested, aes(x=regionalSpRichness, y = CV, color = n, shape = n)) + 
  geom_point(size=5, show.legend = FALSE) +
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=16), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=16),
        axis.title.x=element_text(size=14, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=14, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  geom_smooth(method = lm, se = F, size = 1) +
  scale_color_manual(values = colorsN, limits = catN) +
  scale_shape_manual(values = shapesN, limits = catN) +
  labs(x = "Species Richness
       (Probability of occurrence in at least one patch)",
       y = "CV")


############################################
############################################
############################################

# plot All metrics vs. Species Richness:


# *** See also plots for Loreau & Thibaut metrics of synchrony
SN_GrossAsynWithin_SpRich <- ggplot(data=spatNested, aes(x=regionalSpRichness, y = grossSyncWithin, color = n, shape = n)) + 
  geom_point(size=3, show.legend = F) +
  theme_1_withLegend() +
  scale_y_reverse() +
  geom_smooth(method = lm, se = F, size = 0.75) +
  scale_color_manual(values = colorsN, limits = catN) +
  scale_shape_manual(values = shapesN, limits = catN) +
  labs(x = "Species Richness
       (Probability of occurrence in at least one patch)",
       y = "Gross Asynchrony Within")


SN_GrossAsynBetween_SpRich <- ggplot(data=spatNested, aes(x=regionalSpRichness, y = grossSyncBetween, color = n, shape = n)) + 
  geom_point(size=3, show.legend = F) +
  theme_1_noLegend() +
  scale_y_reverse() +
  geom_smooth(method = lm, se = F, size = 0.75) +
  scale_color_manual(values = colorsN, limits = catN) +
  scale_shape_manual(values = shapesN, limits = catN) +
  labs(x = "Species Richness
       (Probability of occurrence in at least one patch)",
       y = "Gross Asynchrony Between")


    
SN_avSpVar_SpRich <- ggplot(data=spatNested, aes(x=regionalSpRichness, y = avSpVar, color = n, shape = n)) + 
  geom_point(size=3, show.legend = F) +
  theme_1_noLegend() +
  geom_smooth(method = lm, se = F, size = 0.75) +
  scale_color_manual(values = colorsN, limits = catN) +
  scale_shape_manual(values = shapesN, limits = catN) +
  labs(x = "Species Richness
       (Probability of occurrence in at least one patch)",
       y = "Mean Species Variability")



SN_Bray_SpRich <- ggplot(data=spatNested, aes(x=regionalSpRichness, y = bray, color = n, shape = n)) + 
  geom_point(size=3, show.legend = F) +
  theme_1_noLegend() +
  geom_smooth(method = lm, se = F, size = 0.75) +
  scale_color_manual(values = colorsN, limits = catN) +
  scale_shape_manual(values = shapesN, limits = catN) +
  labs(x = "Species Richness
       (Probability of occurrence in at least one patch)",
       y = "Bray Dissimilarity")


grid.arrange(SN_GrossAsynWithin_SpRich, SN_GrossAsynBetween_SpRich, SN_avSpVar_SpRich, SN_Bray_SpRich, ncol=2)

############################################
############################################
############################################


# 3. Random draws of local communities:

# plot CV vs synchrony within local communities (between species)
RA_cvGross_within <- ggplot(data=randomAgg, aes(x=grossSyncWithin, y = CV, color = n, shape = n)) + 
  geom_point(size=2, show.legend = FALSE) +
  theme_1_withLegend() +
  scale_x_reverse(breaks = c(0.05, 0.0, -0.05, -0.1, -0.15), labels = c(0.05, 0.0, -0.05, -0.1, -0.15)) +
  geom_smooth(method = lm, se = F, size = 1) +
  scale_color_manual(values = colorsN, limits = catN) +
  scale_shape_manual(values = shapesN, limits = catN) +
  labs(x = "Gross Asynchrony
       (within-patch, between species)",
       y = "CV (Total Community CUE)")




# plot CV vs synchrony between local communities
RA_cvGross_between <- ggplot(data=randomAgg, aes(x=grossSyncBetween, y = CV, color = n, shape = n)) + 
  geom_point(size=2) +
  theme_1_noLegend() +
  scale_x_reverse() +
  geom_smooth(method = lm, se = F, size = 1) +
  scale_color_manual(values = colorsN, limits = catN) +
  scale_shape_manual(values = shapesN, limits = catN) +
  labs(x = "Gross Asynchrony (between-patch)",
       y = "CV (Total Community CUE)")



# plot CV vs average species variation (within patches)
RA_cv_AvSpVar_within <- ggplot(data=randomAgg, aes(x=avSpVar, y = CV, color = n, shape = n)) + 
  geom_point(size=2) +
  theme_1_noLegend() +
  geom_smooth(method = lm, se = F, size = 1) +
  scale_color_manual(values = colorsN, limits = catN) +
  scale_shape_manual(values = shapesN, limits = catN) +
  labs(x = "Mean Species Variability (Within-Patch)",
       y = "CV (Total Community CUE)")




# CV vs Spatial Turnover:
RA_CV_bray_plot <- ggplot(data=randomAgg, aes(x=bray, y = CV, color = n, shape = n)) + 
  geom_point(size=2) +
  theme_1_noLegend() +
  geom_smooth(method = lm, se = F, size = 1) +
  scale_color_manual(values = colorsN, limits = catN) +
  scale_shape_manual(values = shapesN, limits = catN) +
  labs(x = "Bray Dissimilarity", y = "CV (Total Community CUE)")



grid.arrange(RA_cvGross_within, RA_cvGross_between, RA_cv_AvSpVar_within, RA_CV_bray_plot, ncol = 2)


############################################
############################################

# Plot other stuff:

# CV vs Area
RA_CV_Area_plot <- ggplot(data=randomAgg, aes(x=Area, y = CV, color = n, shape = n)) + 
  geom_point(size=3, show.legend = FALSE) +
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=12), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=12),
        axis.title.x=element_text(size=12, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=12, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  geom_smooth(method = lm, se = F, size = 1) +
  scale_color_manual(values = colorsN, limits = catN) +
  scale_shape_manual(values = shapesN, limits = catN) +
  scale_x_log10(breaks = c(5000, 10000, 20000, 30000, 40000), labels = c(5000, 10000, 20000, 30000, 40000)) +
  geom_smooth(method = lm, se = F) +
  labs(x = "Area (km^2)", y = "CV (Total Community CUE)")



################

# Cumulative Species Richness vs Area:
RA_SpRich_Area_plot <- ggplot(data=randomAgg, aes(x=Area, y = regionalSpRichness, color = n, shape = n)) + 
  geom_point(size=3, show.legend = FALSE) +
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=12), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=12),
        axis.title.x=element_text(size=14, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=14, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  geom_smooth(method = lm, se = F, size = 1) +
  scale_color_manual(values = colorsN, limits = catN) +
  scale_shape_manual(values = shapesN, limits = catN) +
  scale_x_log10(breaks = c(1000, 5000, 10000, 20000, 30000, 40000), labels = c(1000, 5000, 10000, 20000, 30000, 40000)) +
  labs(x = "Area (km^2)", 
       y = "Species Richness
       (Probability of occurrence in at least one patch)", 
       main = "Random Aggregations of Local Communities")


################

# Cumulative Species Richness vs CV:
RA_CV_SpRich <- ggplot(data=randomAgg, aes(x=regionalSpRichness, y = CV, color = n, shape = n)) + 
  geom_point(size=3, show.legend = FALSE) +
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=16), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=16),
        axis.title.x=element_text(size=14, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=14, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  geom_smooth(method = lm, se = F, size = 1) +
  scale_color_manual(values = colorsN, limits = catN) +
  scale_shape_manual(values = shapesN, limits = catN) +
  labs(x = "Species Richness
       (Probability of occurrence in at least one patch)",
       y = "CV")


############################################
############################################
############################################

# plot All metrics vs. Species Richness:


# *** See also plots for Loreau & Thibaut metrics of synchrony
RA_GrossAsynWithin_SpRich <- ggplot(data=randomAgg, aes(x=regionalSpRichness, y = grossSyncWithin, color = n, shape = n)) + 
  geom_point(size=2, show.legend = F) +
  theme_1_withLegend() +
  scale_y_reverse() +
  geom_smooth(method = lm, se = F, size = 0.75) +
  scale_color_manual(values = colorsN, limits = catN) +
  scale_shape_manual(values = shapesN, limits = catN) +
  labs(x = "Species Richness
       (Probability of occurrence in at least one patch)",
       y = "Gross Asynchrony Within")


RA_GrossAsynBetween_SpRich <- ggplot(data=randomAgg, aes(x=regionalSpRichness, y = grossSyncBetween, color = n, shape = n)) + 
  geom_point(size=2, show.legend = F) +
  theme_1_noLegend() +
  scale_y_reverse() +
  geom_smooth(method = lm, se = F, size = 0.75) +
  scale_color_manual(values = colorsN, limits = catN) +
  scale_shape_manual(values = shapesN, limits = catN) +
  labs(x = "Species Richness
       (Probability of occurrence in at least one patch)",
       y = "Gross Asynchrony Between")


    
RA_avSpVar_SpRich <- ggplot(data=randomAgg, aes(x=regionalSpRichness, y = avSpVar, color = n, shape = n)) + 
  geom_point(size=2, show.legend = F) +
  theme_1_noLegend() +
  geom_smooth(method = lm, se = F, size = 0.75) +
  scale_color_manual(values = colorsN, limits = catN) +
  scale_shape_manual(values = shapesN, limits = catN) +
  labs(x = "Species Richness
       (Probability of occurrence in at least one patch)",
       y = "Mean Species Variability")



RA_Bray_SpRich <- ggplot(data=randomAgg, aes(x=regionalSpRichness, y = bray, color = n, shape = n)) + 
  geom_point(size=2, show.legend = F) +
  theme_1_noLegend() +
  geom_smooth(method = lm, se = F, size = 0.75) +
  scale_color_manual(values = colorsN, limits = catN) +
  scale_shape_manual(values = shapesN, limits = catN) +
  labs(x = "Species Richness
       (Probability of occurrence in at least one patch)",
       y = "Bray Dissimilarity")


grid.arrange(RA_GrossAsynWithin_SpRich, RA_GrossAsynBetween_SpRich, RA_avSpVar_SpRich,  RA_Bray_SpRich, ncol=2)


```







Although we can compare local and regional community stability using CVs alone, here we calculate metrics from Wang & Loreau (2014) to help us think about mechanisms underlying this result.
The following uses formulas from Wang & Loreau's (2014) Supp Mat (i.e. for the case where biomass varies within and between local communities).
```{r,  include=FALSE, echo=FALSE, results='hide'}

# Wang & Loreau 2014 equations

# CONSIDER WHETHER TO LOG THE CUES FIRST


# nomenclature for the following calculations:
# i, h = local community i (and h)
# j, k, l = species j, k, l
# j_i = species j in local community i
# u = mean
# w = variance or covariance
# w_kk_i = variance of each species k within local community i
# w_kl_i = covariance between species k and l within local community i
# w_ii = variance (of total community CPUE) for each local community i
# w_ih = covariance (of total community CPUE) between local communities i & h
# rho = temporal Synchrony; inverse is Beta (temporal Asynchrony)


WangLoreau_func <- function(this_df, spatialGrouping){
  
  # create single-level lists:
  Area_agg_list <- list()
  AA_list <- list()#; AAA_list <- list()
  another_df_list <- list(); covMatrix_m_list <- list(); w_ii_list <- list(); w_ih_list <- list()
  summed_w_ih_list <- list(); rho_list <- list(); Beta1_list <- list(); gamma_CV_list <- list()
  

  # create nested lists with 2 levels:
  AAA_list <- vector("list", length(spatialGrouping))
  A_list <- vector("list", length(spatialGrouping))
  B_list <- vector("list", length(spatialGrouping))
  C_list <- vector("list", length(spatialGrouping))
  D_list <- vector("list", length(spatialGrouping))
  E_list <- vector("list", length(spatialGrouping))
  F_list <- vector("list", length(spatialGrouping))
  covMatrix_i_list <- vector("list", length(spatialGrouping))
  w_kk_i_list <- vector("list", length(spatialGrouping))
  rho_species_i_list <- vector("list", length(spatialGrouping)) 
  CV_i_list <- vector("list", length(spatialGrouping))
  u_m_list <- vector("list", length(spatialGrouping))
  alpha_CV_list <- vector("list", length(spatialGrouping))


  
    ###################### 
  
  
    for(j in 1:length(spatialGrouping)) {
      
      AA_list[[j]] <- this_df %>%
        filter(area %in% spatialGrouping[[j]]) 
    
      
      # calculate summed area for each spatial grouping:
      Area_agg_list[[j]] <- AA_list[[j]] %>%
        select(area, km2) %>%
        group_by(area) %>%
        summarise(eachArea = first(km2)) %>%
        ungroup() %>%
        summarise(area_agg = sum(eachArea))
  
        
    ######################    
      
    for(k in 1:length(spatialGrouping[[j]])) {
      
       AAA_list[[j]][[k]] <- this_df %>%
         filter(area %in% spatialGrouping[[j]]) %>%
         filter(area == spatialGrouping[[j]][k])
      
       
      
   ###################### 
       
  # 1. Calculate averaged species variability (C_list$CV_species_i_squared):
  
  # calculate local community-level stuff
    A_list[[j]][[k]] <- AAA_list[[j]][[k]] %>%
      group_by(year) %>%
      summarise(annual_total_i = sum(Mean.totalDensity)) %>% # sum CUEs across all species for each local community in each year
      ungroup() %>%
      summarise(var_i = var(annual_total_i),
                stDev_i = sqrt(var(annual_total_i)),
                u_i = mean(annual_total_i)) # mean total community CUE (across all years) for local community i
    
    
  # calculate species-level stuff
    B_list[[j]][[k]] <- AAA_list[[j]][[k]] %>%
      group_by(Species) %>%
      summarise(u_j_i = mean(Mean.totalDensity), # mean CUE (across all years) of species j in local community i
                CV_j_i_squared = sqrt(var(Mean.totalDensity)) / u_j_i, # CV of species j in local community i; CV = StDev / Mean
                CV_species_j_i = u_j_i / A_list[[j]][[k]]$u_i * CV_j_i_squared) %>% # CV of species in local community i
      ungroup()
    
    
  # calculate averaged species variability
    C_list[[j]][[k]] <- B_list[[j]][[k]] %>%
      summarise(CV_species_i_squared = sum(CV_species_j_i))
    
    
    
      ##############################
    
  # 2. Calculate species asynchrony WITHIN local areas (rho_species_i_list):
    D_list[[j]][[k]] <- AAA_list[[j]][[k]] %>%
      select(year, Mean.totalDensity, Species) %>%
      spread(Species, Mean.totalDensity) %>%
      select(-year)
    
    covMatrix_i_list[[j]][[k]] <- cov(D_list[[j]][[k]]) # create the covariance matrix
    
    w_kk_i_list[[j]][[k]] <- diag(covMatrix_i_list[[j]][[k]]) # extract diagonals of the covariance matrix. these are temporal variance of each species k within local community i
    
    covMatrix_i_list[[j]][[k]][upper.tri(covMatrix_i_list[[j]][[k]], diag = TRUE)] <- NA # for each local community i, keep one copy of all the non-diagonals. these are w_kl_i
    E_list[[j]][[k]] <- as.data.frame(covMatrix_i_list[[j]][[k]])
    
    F_list[[j]][[k]] <- E_list[[j]][[k]] %>%
       summarise(sum_w_kl_i = sum(E_list[[j]][[k]][,1:53], na.rm = T)) # for each local community i, find the sum of all w_kl_i. calc has been checked
    
    rho_species_i_list[[j]][[k]] <- F_list[[j]][[k]]$sum_w_kl_i / ((sum(sqrt(w_kk_i_list[[j]][[k]][1:53])))^2)
  
  
  ##############################
  # 3. Calculate Variability of local community k
    CV_i_list[[j]][[k]] <- C_list[[j]][[k]]$CV_species_i_squared * rho_species_i_list[[j]][[k]] # It's not clear whether this should be squared. If not squred, returns a negative value when within-patch species synchrony is negative
  # CHECK WHETHER LOCAL COMMUNITY VARIABILITY CORRELATES WITH SIZE (AREA) OF LOCAL COMMUNITY (IE DO LARGER AREAS SHOW MORE VARIABILITY?)


  ##############################
  # 4. Calculate Alpha variability (local community variability weighed for local community CPUE)
    u_m_list[[j]] <- sum(A_list[[j]][[k]]$u_i)
    alpha_CV_list[[j]] <- (sum(A_list[[j]][[k]]$u_i / u_m_list[[j]] * CV_i_list[[j]][[k]]))^2
  
    
  ##############################
    
    } # end of k
    

  ############################################################
  # 5. Calculate Beta variability (spatial synchrony; rho)
  # note I'm replacing Wang & Loreau's local patch i & j notation with i & h, to avoid confusion with their species j
    
  another_df_list[[j]] <- AA_list[[j]] %>%  
    group_by(area, year) %>%
    summarise(ann_tot_i = sum(Mean.totalDensity)) %>%
    ungroup() %>%
    spread(area, ann_tot_i) %>%
    select(-year)
  
  
    covMatrix_m_list[[j]] <- cov(another_df_list[[j]]) # create the covariance matrix of each local community j
  
    w_ii_list[[j]] <- diag(covMatrix_m_list[[j]]) # extract diagonals of the covariance matrix. returns a vector. this is temporal variance of total community CPUE, within each local community j.
  
    covMatrix_m_list[[j]][upper.tri(covMatrix_m_list[[j]], diag = TRUE)] <- NA # keep one copy of all the non-diagonals. These are w_ih (temporal covariance of total community biomass between local patches i & h). NB it would be nice to bring in species-level information here, to prevent dominant species from driving the result.
    w_ih_list[[j]] <- as.data.frame(covMatrix_m_list[[j]])
  
    summed_w_ih_list[[j]] <- w_ih_list[[j]] %>% 
      summarise(sum_w_ih = sum(w_ih_list[[j]][,1:ncol(w_ih_list[[j]])], na.rm = T)) # find the sum of all w_ih. calc has been checked

    rho_list[[j]] <- summed_w_ih_list[[j]]$sum_w_ih / ((sum( sqrt(w_ii_list[[j]][1:length(w_ii_list[[j]])]) ))^2) # Wang & Loreau (2014) claim that standardizing for within-patch covariance accounts for spatial uneveness in biomass. Not sure about this.
  
    Beta1_list[[j]] <- 1 / rho_list[[j]]


  ##############################
  # 6. Calculate Gamma variability
  
  gamma_CV_list[[j]] <- alpha_CV_list[[j]] / Beta1_list[[j]]
  
  
    } # end of j
  
  
  ##############################
  
  # 7. Return dataframe of outputs
  
    WangLoreau_list <- list(Area_agg_list, alpha_CV_list, rho_list, gamma_CV_list)
    WangLoreau_df <- as.data.frame(matrix(unlist(WangLoreau_list), nrow=length(unlist(WangLoreau_list[1]))))
    colnames(WangLoreau_df) <- c("Area", "alphaCV", "Rho", "gammaCV")
    WangLoreau_df <- mutate(WangLoreau_df, id = rownames(WangLoreau_df)) # add column with unique number
    
    return(WangLoreau_df)
  
}


WangLoreauResult <- WangLoreau_func(shallowCPUEArea2, myNums_agg_list)
WangLoreauResult


#alpha <- plot(log(WangLoreauResult$gammaCV) ~ log(WangLoreauResult$alphaCV), pch=16, cex=1.5)
#rho <- plot(log(WangLoreauResult$gammaCV) ~ log(WangLoreauResult$Rho), pch=16, cex=1.5)

```



```{r, echo=F, fig.height=10, fig.width=10}

# plot output of Wang & Loreau 2014 equations:

alphaCV_plot <- ggplot(data=WangLoreauResult, aes(x=Area, y = alphaCV)) + 
  geom_point(aes(y = alphaCV), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=8), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=10),
        axis.title.x=element_text(size=12, margin=margin(7,0,0,0)),
        axis.title.y=element_text(size=12, angle=90, margin=margin(0,7,0,0)),
        plot.title = element_text(size=18)) +
  
  scale_x_log10(breaks = c(5000, 10000, 20000, 30000, 40000), labels = c(5000, 10000, 20000, 30000, 40000)) +
  
  scale_y_log10() +
  
  geom_smooth(method = lm, se = FALSE) +
  
  labs(x = "Area (km^2)", 
       y = "Alpha CV")




rho_plot <- ggplot(data=WangLoreauResult, aes(x=Area, y = Rho)) + 
  geom_point(aes(y = Rho), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=8), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=10),
        axis.title.x=element_text(size=12, margin=margin(7,0,0,0)),
        axis.title.y=element_text(size=12, angle=90, margin=margin(0,7,0,0)),
        plot.title = element_text(size=18)) +
  
  scale_x_log10(breaks = c(5000, 10000, 20000, 30000, 40000), labels = c(5000, 10000, 20000, 30000, 40000)) +
  
  scale_y_log10(breaks = c(0.001, 0.01, 0.1, 0.2), labels = c(0.001, 0.01, 0.1, 0.2)) +
  
  geom_smooth(method = lm, se = FALSE) +
  
  labs(x = "Area (km^2)", 
       y = "Rho")
  
  




gammaCV_plot <- ggplot(data=WangLoreauResult, aes(x=Area, y = gammaCV)) + 
  geom_point(aes(y = gammaCV), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=8), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=10),
        axis.title.x=element_text(size=12, margin=margin(7,0,0,0)),
        axis.title.y=element_text(size=12, angle=90, margin=margin(0,7,0,0)),
        plot.title = element_text(size=18)) +
  
  scale_x_log10(breaks = c(5000, 10000, 20000, 30000, 40000), labels = c(5000, 10000, 20000, 30000, 40000)) +
  
  scale_y_log10(breaks = c(0.00000001, 0.0000001, 0.000001, 0.00001, 0.0001), labels = c(0.00000001, 0.0000001, 0.000001, 0.00001, 0.0001)) +
  
  geom_smooth(method = lm, se = FALSE) +
  
  labs(x = "Area (km^2)", 
       y = "Gamma CV")




grid.arrange(alphaCV_plot, rho_plot, gammaCV_plot, ncol = 2)

```




```{r, echo=F, fig.height=10, fig.width=10}

# plot more stuff

# bind all dataframes together:
mydat <- list(richness1, allCV, WangLoreauResult) %>%
  Reduce(function(x, y) left_join(x, y, by="Area"), .) %>%
  distinct()



gammaCV_spRichness <- ggplot(data=mydat, aes(x=speciesRichness, y = gammaCV)) + 
  geom_point(aes(y = gammaCV), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=12), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=12),
        axis.title.x=element_text(size=14, margin=margin(7,0,0,0)),
        axis.title.y=element_text(size=14, angle=90, margin=margin(0,7,0,0)),
        plot.title = element_text(size=18)) +
  
  #scale_x_log10(breaks = c(5000, 10000, 20000, 30000, 40000), labels = c(5000, 10000, 20000, 30000, 40000)) +
  
  scale_y_log10(breaks = c(0.00000001, 0.0000001, 0.000001, 0.00001, 0.0001), labels = c(0.00000001, 0.0000001, 0.000001, 0.00001, 0.0001)) +
  
  geom_smooth(method = lm, se = FALSE) +
  
  labs(x = "Species Richness
 (max. probability of occurrence)", 
       y = "Gamma CV")




CV_spRichness <- ggplot(data=mydat, aes(x=speciesRichness, y = CV)) + 
  geom_point(aes(y = CV), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=12), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=12),
        axis.title.x=element_text(size=14, margin=margin(7,0,0,0)),
        axis.title.y=element_text(size=14, angle=90, margin=margin(0,7,0,0)),
        plot.title = element_text(size=18)) +
  
  #scale_y_log10(breaks = c(0.00000001, 0.0000001, 0.000001, 0.00001, 0.0001), labels = c(0.00000001, 0.0000001, 0.000001, 0.00001, 0.0001)) +
  
  geom_smooth(method = lm, se = FALSE) +
  
  labs(x = "Species Richness
 (max. probability of occurrence)", 
       y = "CV of Total Community CUE")




CV_gammaCV_raw_scale <- ggplot(data=mydat, aes(x=CV, y = gammaCV)) + 
  geom_point(aes(y = gammaCV), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=12), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=12),
        axis.title.x=element_text(size=14, margin=margin(7,0,0,0)),
        axis.title.y=element_text(size=14, angle=90, margin=margin(0,7,0,0)),
        plot.title = element_text(size=18)) +
  
  labs(x = "CV of Total Community CUE", 
       y = "Gamma CV")




CV_gammaCV_log_scale <- ggplot(data=mydat, aes(x=CV, y = gammaCV)) + 
  geom_point(aes(y = gammaCV), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=12), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=12),
        axis.title.x=element_text(size=14, margin=margin(7,0,0,0)),
        axis.title.y=element_text(size=14, angle=90, margin=margin(0,7,0,0)),
        plot.title = element_text(size=18)) +
  
  scale_y_log10(breaks = c(0.00000001, 0.0000001, 0.000001, 0.00001, 0.0001), labels = c(0.00000001, 0.0000001, 0.000001, 0.00001, 0.0001)) +
  
  #geom_smooth(method = lm, se = FALSE) +
  
  labs(x = "CV of Total Community CUE", 
       y = "Gamma CV")



grid.arrange(CV_spRichness, gammaCV_spRichness, CV_gammaCV_raw_scale, CV_gammaCV_log_scale, ncol = 2)

```










###Within-patch sums of all between-species covariances. Negative values indicate asynchrony.
```{r, echo=F, fig.height=2.75, fig.width=4}
# F_list
F_df <- data.frame(matrix(NA_real_, nrow = 9, ncol = 2)); 
colsF <- c("Area", "sum_w_kl_i"); colnames(F_df) <- colsF
areaNum <- as.vector(1:9); F_df[,1] <- as.factor(areaNum)

for(i in seq_along(F_list)) {
  F_df[i,2] <- data.frame(as.data.frame(F_list[[i]]$sum_w_kl_i))
}


# plot
cov.within_shallow <- ggplot(data=F_df, aes(x=areaNum, y = sum_w_kl_i)) + 
  geom_point(aes(y = sum_w_kl_i), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black")) +
  
  scale_x_continuous(breaks = c(1:9)) +
  
  labs(x = "Area", y = "sum_w_kl_i", title = "Shallow Areas")

cov.within_shallow
```


```{r, include=FALSE, echo=FALSE, results='hide'}
# Within-patch species asynchrony:
# rho_species_i_list
rho_sp_df <- data.frame(matrix(NA_real_, nrow = 9, ncol = 2)); 
cols_rho_sp <- c("Area", "rho_species_i"); colnames(rho_sp_df) <- cols_rho_sp
areaNum <- as.vector(1:9); rho_sp_df[,1] <- as.factor(areaNum)

for(i in seq_along(rho_species_i_list)) {
  rho_sp_df[i,2] <- data.frame(as.data.frame(rho_species_i_list[[i]]))
}


# plot
asynch.within <- ggplot(data=rho_sp_df, aes(x=areaNum, y = rho_species_i)) + 
  geom_point(aes(y = rho_species_i), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black")) +
  
  scale_x_continuous(breaks = c(1:9)) +
  
  labs(x = "Area", y = "rho_species_i")

asynch.within
```


```{r, include=FALSE, echo=FALSE, results='hide'}
# Within-patch variability (ie CVs of total community CPUE within local communities):
# CV_i_list
CV_i_df <- data.frame(matrix(NA_real_, nrow = 9, ncol = 2)); 
cols_CV_i <- c("Area", "CV_i"); colnames(CV_i_df) <- cols_CV_i
areaNum <- as.vector(1:9); CV_i_df[,1] <- as.factor(areaNum)

for(i in seq_along(CV_i_list)) {
  CV_i_df[i,2] <- data.frame(as.data.frame(CV_i_list[[i]]))
}

# plot
CV.within <- ggplot(data=CV_i_df, aes(x=areaNum, y = CV_i)) + 
  geom_point(aes(y = CV_i), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black")) +
  
  scale_x_continuous(breaks = c(1:9)) +
  
  labs(x = "Area", y = "CV_i")

CV.within
```


###Alpha variability (temporal variability at the local scale (NB weighed for local community biomass)):
```{r}
alpha_CV
```


### Spatial synchrony:
```{r}
rho
```


### Within-patch variance (ie temporal variance of each local area's total community CPUE, within local communities):
```{r}
w_ii
```


### Temporal covariance of total community CPUE between all pairs of local communities. Broadly speaking, local areas 1-6 covary positively with eachother, as do areas 7-9. Areas 1-6 covary negatively with 7-9.
```{r}
w_ih
```


###Beta variability (Multiplicative beta variability, i.e. the degree of spatial asynchrony):
```{r}
Beta1
```


###Gamma variability (temporal variability at the metacommunity scale):
```{r}
gamma_CV
```




```{r, echo=F, fig.height=3.5, fig.width=8}

# Shallow areas:
CV_shallow <- shallowCPUEArea2 %>% 
  group_by(area, year) %>%
  summarise(total = sum(Mean.totalDensity)) %>%
  ungroup() %>%
  
  group_by(area) %>%
  summarise(CV = sd(total) / mean(total)) %>%
  ungroup() %>%
  
  left_join(area, by = "area") # add area data

# mean CV of shallow local areas
# CV_shallow %>%
#   filter(area != "Total") %>%
#   summarise(mean = mean(CV), sd = sd(CV))
# 0.171/0.073 # ratio of mean local / regional = 2.342 for shallow areas


# plot on a log scale
CV_shallow_plot <- ggplot(data=CV_shallow, aes(x=area, y = CV)) + 
  geom_point(aes(y = CV), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=12), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=12),
        axis.title.x=element_text(size=12, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=12, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  
  scale_x_discrete(limits=c(1:10, "Region")) +

  scale_y_log10(breaks = c(0.07, 0.08, 0.09, 0.1, 0.15, 0.2)) +
  
  labs(x = "Local Community", y = "CV (Total CPUE)", title = "Shallow Areas")



##############################

# Deep areas:
CV_deep <- deepCPUEArea2 %>% 
  group_by(area, year) %>%
  summarise(total = sum(Mean.totalDensity)) %>%
  ungroup() %>%
  
  group_by(area) %>%
  summarise(CV = sd(total) / mean(total)) %>%
  ungroup()

# mean CV of deep local areas
# CV_deep %>%
#   filter(area != "Total") %>%
#   summarise(mean = mean(CV), sd = sd(CV))
# 0.253/0.187 # ratio of mean local / regional = 1.353 for deep areas


# plot on a log scale
CV_deep_plot <- ggplot(data=CV_deep, aes(x=area, y = CV)) + 
  geom_point(aes(y = CV), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=12), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=12),
        axis.title.x=element_text(size=12, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=12, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  
  scale_y_log10(breaks = c(0.15, 0.2, 0.25, 0.3, 0.35, 0.4)) +
  
  labs(x = "Local Community", y = "CV (Total CPUE)", title = "Deep Areas")



grid.arrange(CV_shallow_plot, CV_deep_plot, ncol=2)


##########

# plot CV vs area
ggplot(data=CV_shallow, aes(x=km2, y = CV)) + 
  geom_point(aes(y = CV), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=10), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=10),
        axis.title.x=element_text(size=12, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=12, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  
  #scale_x_discrete(limits=c(1000, 5000, 10000, 20000, 30000, 40000, 50000, "Region")) +
  
  scale_x_log10(breaks = c(5000, 10000, 20000, 30000, 40000)) +

  scale_y_log10(breaks = c(0.07, 0.08, 0.09, 0.1, 0.15, 0.2)) +
  
  labs(x = "Area of Local Community (km2)", y = "CV (Total CPUE)", title = "Shallow Areas")

```




``` {r}
# Replicate Fig. 1 in Wang & Loreau 2014:
# Create nested plots, growing area in nested fashion starting from Local Community 1 and 10:

a <- list(1); b <- list(1:2); c <- list(1:3); d <- list(1:4); e <- list(1:5)
f <- list(1:6); g <- list(1:7); h <- list(1:8); k <- list(1:9); l <- list(1:10)
corner1_list <- c(a, b, c, d, e, f, g, h, k, l)

m <- list(10); q <- list(9:10); r <- list(8:10); s <- list(7:10); t <- list(6:10)
u <- list(5:10); v <- list(4:10); w <- list(3:10); z <- list(2:10); zz <- list(1:10)
corner10_list <- c(m, q, r, s, t, u, v, w, z, zz)


corner1 <- CV_Area_func(shallowCPUEArea2, corner1_list)
for(i in 1:nrow(corner1)) {
  corner1$startingFrom[[i]] <- "East -> West" 
}

corner10 <- CV_Area_func(shallowCPUEArea2, corner10_list)
for(i in 1:nrow(corner10)) {
  corner10$startingFrom[[i]] <- "West -> East" 
}

plotting_df <- rbind(corner1, corner10)


############

ggplot(data=plotting_df, aes(x=Area, y = CV, color = startingFrom)) + 
  #geom_point(aes(y = CV), size=2) +
  geom_line(aes(y = CV), size = 1) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=12), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=12),
        axis.title.x=element_text(size=12, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=12, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  
  scale_x_log10(breaks = c(5000, 10000, 20000, 30000, 40000), labels = c(5000, 10000, 20000, 30000, 40000)) +
  
  labs(x = "Area (km^2)", y = "CV of Total Community CUE")


```