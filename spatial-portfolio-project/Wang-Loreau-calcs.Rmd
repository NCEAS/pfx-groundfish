---
title: "Local vs Regional Stability of Gulf of Alaksa Groundfish Assemblages"
author: "Colette Ward"
date: "July 12, 2016"
output: pdf_document

# *** NB This is a code dump. Needs significant cleaning up. ***
---


```{r, include=FALSE, echo=FALSE, results='hide'}
# Load packages
library(plyr)
library(dplyr)
library(tidyr)
library(vegan)
library(mvnormtest)
library(synchrony)
library(ggplot2)
library(gridExtra)

```


```{r,  include=FALSE, echo=FALSE, results='hide'}

# load & prep look-up table of common names
common <- read.csv("./diversity-data/trawl_species_control_file.csv", header = T, stringsAsFactors = FALSE)

common1 <- common %>%
  select(database.name, common.name) %>%
  rename(Species = database.name)
for (i in 1:nrow(common1)) { # add common names for Sebastes 1 & 2
  if(common1$Species[i] == "Dusky.and.Dark.Rockfish") {common1$common.name[i] <- "Sebastes 1"}
  if(common1$Species[i] == "Rougheye.and.Blackspotted.Rockfish") {common1$common.name[i] <- "Sebastes 2"}
}


# load area file
area <- read.csv("./spatial-portfolio-project/local-community-area.csv", header = T, stringsAsFactors = F) # note area numbers do not need updating; they reflect remove Ole's area 8

```


```{r,  include=FALSE, echo=FALSE, results='hide'}
# load & prep mean annual CPUE data for Shallow Areas:
shallowCPUEArea <- read.csv("./diversity-data/All_sp_index_meanCPUEByArea.csv", header = T, stringsAsFactors = FALSE)

shallowCPUEArea2 <- left_join(shallowCPUEArea, common1, by = "Species") %>% # merge common names onto SPCPUEArea
  select(area, Mean.totalDensity, SD.totalDensity, year, Species, common.name) %>%
  filter(area != "8") %>% # remove Ole's area 8
  mutate(area = revalue(area, c("9"="8", "10"="9", "11"="10"))) %>% # renumber (old = new) shallow areas to account for splitting area 7 into 7, 8, 9 but removing 8
  mutate(area = revalue(area, c("Total" = "Region"))) %>%
  left_join(area, by = "area") %>%
  filter(area != "Region") %>% # run as needed for analyses below
  mutate(area = as.numeric(area))


# remove top 4 most numerically doominant species
subdom1 <- shallowCPUEArea2 %>%
  filter(!common.name %in% c("arrowtooth flounder", "Pacific halibut", "walleye pollock", "Pacific cod"))


# remove top 8 most numerically doominant species
subdom2 <- shallowCPUEArea2 %>%
  filter(!common.name %in% c("arrowtooth flounder", "Pacific halibut", "walleye pollock", "Pacific cod", "northern rockfish", "rock soles", "Pacific ocean perch", "flathead sole"))


# remove the 2 top predators from the group of the 4 most numerically doominant species
subdom3 <- shallowCPUEArea2 %>%
  filter(!common.name %in% c("arrowtooth flounder", "Pacific halibut"))

```

```{r,  include=FALSE, echo=FALSE, results='hide'}
# load mean annual CPUE for Deep areas:
deepCPUEArea <- read.csv("./diversity-data/All_sp_index_meanCPUEByArea.Deep.MH.final.csv", header = T, stringsAsFactors = FALSE) # this is the latest file created by Mary Oct 26 2016

deepCPUEArea2 <- left_join(deepCPUEArea, common1, by = "Species") %>% # merge in common names
  select(area, Mean.totalDensity, SD.totalDensity, year, Species, common.name) %>%
  mutate(area = revalue(area, c("1"="11", "2"="12", "3"="14", "4"="15", "5"="13", "Total" = "Region")))  %>% # renumbering areas
  left_join(area, by = "area")

```


```{r,  include=FALSE, echo=FALSE, results='hide'}

# set working directory
setwd("~/Google Drive/GoA project/pfx-groundfish/spatial-portfolio-project")

```


```{r,  include=FALSE, echo=FALSE, results='hide'}

# Create spatially-nested groupings for shallow communities:
# *OLD incomplete list

# 1:
aa <- list(1)
ab <- list(2)
ac <- list(3)
ad <- list(4)
ae <- list(5)
af <- list(6)
ag <- list(7)
ah <- list(8)
ak <- list(9)
al <- list(10)

#am <- list(1:4)
#an <- list(5:7)
#ao <- list(8:10)
#aq <- list(1:10)
big_list <- c(aa, ab, ac, ad, ae, af, ag, ah, ak, al, am, an, ao, aq)

# 2:
a <- list(1:2)
b <- list(3:4)
c <- list(5:6)
d <- list(7:8)
e <- list(9:10)

# 3:
f <- list(1:3)
fa <- list(2:4)
fb <- list(3:5)
g <- list(4:6)
n <- list(5:7)
gb <- list(6:8)
h <- list(7:9)
o <- list(8:10)

# 4:
m <- list(1:4)
k <- list(5:8)
u <- list(2:5)
v <- list(3:6)
w <- list(4:7)
z <- list(5:8)
za <- list(6:9)
zb <- list(7:10)


# 5:
t <- list(1:5)
l <- list(6:10)


#6:
zc <- list(1:6)
w <- list(5:10)


# 7:
r <- list(1:7)
s <- list(2:8)
zd <- list(3:9)
zz <- list(4:10)


# 10:
q <- list(1:10)


#agg_list <- c(m, n, o, r, q)
#agg_list <- c(aa, ab, ac, ad, ae, af, ag, ah, ak, al, a, b, c, d, e, f, g, h, k, l, t, v, w, zz, m, n, o, r, q)
agg_2s <- c(a, b, c, d, e)
agg_3s <- c(f, fa, fb, g, n, gb, h, o)
agg_4s <- c(m, k, u, v, w, z, za, zb)
#agg_list <- c(a, b, c, d, e, f, g, h, k, l, t, v, w, zz, m, n, o, r, q)

local_list <- c(aa, ab, ac, ad, ae, af, ag, ah, ak, al)
local_agg_list <- c(aa, ab, ac, ad, ae, af, ag, ah, ak, al, # local communities, no aggregation
                    a, b, c, d, e, # 2s
                    f, fa, fb, g, n, gb, h, o, # 3s
                    m, k, u, v, w, z, za, zb, # 4s
                    l, t, zc, w, r, s, zd, zz, q) # the rest
agg_only_list <- c(a, b, c, d, e, f, fa, fb, g, n, gb, h, o, m, k, u, v, w, z, za, zb, l, t, zc, w, r, s, zd, zz, q)

##################################################
##################################################
##################################################


# Create spatially-nested groupings for shallow communities:

# 1:
a1 <- list(1)
a2 <- list(2)
a3 <- list(3)
a4 <- list(4)
a5 <- list(5)
a6 <- list(6)
a7 <- list(7)
a8 <- list(8)
a9 <- list(9)
a10 <- list(10)


# 2:
b1 <- list(1:2)
b2 <- list(2:3)
b3 <- list(3:4)
b4 <- list(4:5)
b5 <- list(5:6)
b6 <- list(6:7)
b7 <- list(7:8)
b8 <- list(8:9)
b9 <- list(9:10)


# 3:
c1 <- list(1:3)
c2 <- list(2:4)
c3 <- list(3:5)
c4 <- list(4:6)
c5 <- list(5:7)
c6 <- list(6:8)
c7 <- list(7:9)
c8 <- list(8:10)


# 4:
d1 <- list(1:4)
d2 <- list(2:5)
d3 <- list(3:6)
d4 <- list(4:7)
d5 <- list(5:8)
d6 <- list(6:9)
d7 <- list(7:10)


# 5:
e1 <- list(1:5)
e2 <- list(2:6)
e3 <- list(3:7)
e4 <- list(4:8)
e5 <- list(5:9)
e6 <- list(6:10)


#6:
f1 <- list(1:6)
f2 <- list(2:7)
f3 <- list(3:8)
f4 <- list(4:9)
f5 <- list(5:10)


# 7:
g1 <- list(1:7)
g2 <- list(2:8)
g3 <- list(3:9)
g4 <- list(4:10) 


# 8:
h1 <- list(1:8)
h2 <- list(2:9)
h3 <- list(3:10)


# 9:
j1 <- list(1:9)
j2 <- list(2:10)


# 10:
k1 <- list(1:10)


spatially_nested_list <- c(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
                           b1, b2, b3, b4, b5, b6, b7, b8, b9,
                           c1, c2, c3, c4, c5, c6, c7, c8,
                           d1, d2, d3, d4, d5, d6, d7,
                           e1, e2, e3, e4, e5, e6,
                           f1, f2, f3, f4, f5,
                           g1, g2, g3, g4,
                           h1, h2, h3,
                           j1, j2,
                           k1)

spatially_nested_list_noSingles <- c(b1, b2, b3, b4, b5, b6, b7, b8, b9,
                                     c1, c2, c3, c4, c5, c6, c7, c8,
                                     d1, d2, d3, d4, d5, d6, d7,
                                     e1, e2, e3, e4, e5, e6,
                                     f1, f2, f3, f4, f5,
                                     g1, g2, g3, g4,
                                     h1, h2, h3,
                                     j1, j2,
                                     k1)



##################################################
##################################################
##################################################

# create 100 random draws of 2, 3, 4, ... 9 local communities

myNums1_list <- list()
myNums2_list <- list()
myNums3_list <- list()
myNums4_list <- list()
myNums5_list <- list()
myNums6_list <- list()
myNums7_list <- list()
myNums8_list <- list()
myNums9_list <- list()

for (i in 1:100) {
  myNums1_list[[i]] <- sample(seq(1:10), size = 1)
  myNums2_list[[i]] <- sample(seq(1:10), size = 2)
  myNums3_list[[i]] <- sample(seq(1:10), size = 3)
  myNums4_list[[i]] <- sample(seq(1:10), size = 4)
  myNums5_list[[i]] <- sample(seq(1:10), size = 5)
  myNums6_list[[i]] <- sample(seq(1:10), size = 6)
  myNums7_list[[i]] <- sample(seq(1:10), size = 7)
  myNums8_list[[i]] <- sample(seq(1:10), size = 8)
  myNums9_list[[i]] <- sample(seq(1:10), size = 9)
}
myNums10_list <- list(1:10)

myNums_agg_list <- c(myNums1_list, myNums2_list, myNums3_list, myNums4_list, myNums5_list, myNums6_list, myNums7_list, myNums8_list, myNums9_list, myNums10_list)


myNums_agg_list_noSingles <- c(myNums2_list, myNums3_list, myNums4_list, myNums5_list, myNums6_list, myNums7_list, myNums8_list, myNums9_list, myNums10_list)
#save(myNums_agg_list_noSingles, file = "myNums_agg_list_noSingles.RData")
load("myNums_agg_list_noSingles.RData")


myNums_agg_list
#save(myNums_agg_list, file = "myNums_agg_list.RData")
load("myNums_agg_list.RData")



################

# Create spatial groupings for pairwise dissimilarity indices:

myNums2_list[[2]]

myNums4_list[[2]]
# split the list in half using length(myNums4_list[[2]]/2)
length(myNums4_list[[2]])/2


# 1. Create k subgroupings of local communities
a <- list(1:2)
b <- list(3:4)
c <- list(5:6)
d <- list(7:8)
e <- list(9:10)

f <- list(1:3)
g <- list(4:6)
h <- list(5:7)
m <- list(8:10)

q <- list(1:4)
r <- list(5:8)
s <- list(3:6)
t <- list(7:10)

u <- list(1:5)
v <- list(6:10)


# 2. Create j pairs of k subgroupings
b1 <- c(a, b)  # 1:2, 3:4
b2 <- c(b, c)  # 3:4, 5:6
b3 <- c(c, d)  # 5:6, 7:8
b4 <- c(d, e)  # 7:8, 9:10

b5 <- c(f, g) # 1:3, 4:6
b6 <- c(h, m) # 5:7, 8:10

b7 <- c(q, r) # 1:4, 5:8
b8 <- c(s, t) # 3:6, 7:10

b9 <- c(u, v) # 1:5, 6:10


# 3. Create list of j pairs
#spatialPairs <- list(b1, b2, b3, b4)
spatialPairs <- list(b1, b2, b3, b4, b5, b6, b7, b8, b9)
spatialPairs

```


To address local vs regional community stability we can compare CVs of total CPUE between local communities and the regional metacommunity.
The regional community does indeed show greater stability than local communities. Note that y-axis scales differ - deep areas are generally less stable than shallow areas.  
**The magnitude of the portfolio effect can be assessed from the ratio of mean local CV / regional CV (ie the increase in stability that arises from spatial (beta) diversity; values >1 indicate a stabilizing effect): the ratio is ~2.3 for shallow areas and ~1.4 for deep areas.** (I'm not sure the difference between effect size in shallow and deep is meaningful, it may arise because we have more local patches for shallow areas.)  
[If anyone wants to make these plots prettier, please do :) ]


```{r, echo=F, fig.height=3.5, fig.width=8}

# Shallow areas:
CV_shallow <- shallowCPUEArea2 %>% 
  group_by(area, year) %>%
  summarise(total = sum(Mean.totalDensity)) %>%
  ungroup() %>%
  
  group_by(area) %>%
  summarise(CV = sd(total) / mean(total)) %>%
  ungroup() %>%
  
  left_join(area, by = "area") # add area data

# mean CV of shallow local areas
# CV_shallow %>%
#   filter(area != "Total") %>%
#   summarise(mean = mean(CV), sd = sd(CV))
# 0.171/0.073 # ratio of mean local / regional = 2.342 for shallow areas


# plot on a log scale
CV_shallow_plot <- ggplot(data=CV_shallow, aes(x=area, y = CV)) + 
  geom_point(aes(y = CV), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=12), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=12),
        axis.title.x=element_text(size=12, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=12, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  
  scale_x_discrete(limits=c(1:10, "Region")) +

  scale_y_log10(breaks = c(0.07, 0.08, 0.09, 0.1, 0.15, 0.2)) +
  
  labs(x = "Local Community", y = "CV (Total CPUE)", title = "Shallow Areas")



##############################

# Deep areas:
CV_deep <- deepCPUEArea2 %>% 
  group_by(area, year) %>%
  summarise(total = sum(Mean.totalDensity)) %>%
  ungroup() %>%
  
  group_by(area) %>%
  summarise(CV = sd(total) / mean(total)) %>%
  ungroup()

# mean CV of deep local areas
# CV_deep %>%
#   filter(area != "Total") %>%
#   summarise(mean = mean(CV), sd = sd(CV))
# 0.253/0.187 # ratio of mean local / regional = 1.353 for deep areas


# plot on a log scale
CV_deep_plot <- ggplot(data=CV_deep, aes(x=area, y = CV)) + 
  geom_point(aes(y = CV), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=12), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=12),
        axis.title.x=element_text(size=12, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=12, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  
  scale_y_log10(breaks = c(0.15, 0.2, 0.25, 0.3, 0.35, 0.4)) +
  
  labs(x = "Local Community", y = "CV (Total CPUE)", title = "Deep Areas")



grid.arrange(CV_shallow_plot, CV_deep_plot, ncol=2)


##########

# plot CV vs area
ggplot(data=CV_shallow, aes(x=km2, y = CV)) + 
  geom_point(aes(y = CV), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=10), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=10),
        axis.title.x=element_text(size=12, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=12, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  
  #scale_x_discrete(limits=c(1000, 5000, 10000, 20000, 30000, 40000, 50000, "Region")) +
  
  scale_x_log10(breaks = c(5000, 10000, 20000, 30000, 40000)) +

  scale_y_log10(breaks = c(0.07, 0.08, 0.09, 0.1, 0.15, 0.2)) +
  
  labs(x = "Area of Local Community (km2)", y = "CV (Total CPUE)", title = "Shallow Areas")

```



```{r, echo=FALSE, fig.height=3.5, fig.width=8}

# Calculate & plot CV vs Area (km^2)

CV_Area_func <- function(my_df, spatialGrouping){
  
  CV_agg_list <- list()
  Area_agg_list <- list()
  df_list <- list()
  
  for(i in seq_along(spatialGrouping)) {
  
                CV_agg_list[[i]] <- my_df %>%
                          filter(area %in% spatialGrouping[[i]]) %>%
                          group_by(year) %>%
                          summarise(total = sum(Mean.totalDensity)) %>%
                          ungroup() %>%
                          summarise(CV = sd(total) / mean(total))
  
                Area_agg_list[[i]] <- my_df %>%
                            filter(area %in% spatialGrouping[[i]]) %>%
                            select(area, km2) %>%
                            group_by(area) %>%
                            summarise(eachArea = first(km2)) %>%
                            ungroup() %>%
                            summarise(area_agg = sum(eachArea))
  }
  
  df_list <- list(Area_agg_list, CV_agg_list)
  my_df <- as.data.frame(matrix(unlist(df_list), nrow=length(unlist(df_list[1]))))
  colnames(my_df) <- c("Area", "CV")
  return(my_df)
  
}


####################################


allCV <- CV_Area_func(shallowCPUEArea2, myNums_agg_list_noSingles)
#save(allCV, file = "allCV.RData")
load("allCV.RData")
#View(allCV)

ggplot(data=allCV, aes(x=Area, y = CV)) + 
  geom_point(aes(y = CV), size=4) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=12), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=12),
        axis.title.x=element_text(size=12, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=12, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  
  scale_x_log10(breaks = c(5000, 10000, 20000, 30000, 40000), labels = c(5000, 10000, 20000, 30000, 40000)) +
  
  geom_smooth(method = lm) +
  
  labs(x = "Area (km^2)", y = "CV (Total Community CUE)")



####################################


# Create nested plots, growing area in nested fashion starting from Local Community 1 and 10:

a <- list(1); b <- list(1:2); c <- list(1:3); d <- list(1:4); e <- list(1:5)
f <- list(1:6); g <- list(1:7); h <- list(1:8); k <- list(1:9); l <- list(1:10)
corner1_list <- c(a, b, c, d, e, f, g, h, k, l)

m <- list(10); q <- list(9:10); r <- list(8:10); s <- list(7:10); t <- list(6:10)
u <- list(5:10); v <- list(4:10); w <- list(3:10); z <- list(2:10); zz <- list(1:10)
corner10_list <- c(m, q, r, s, t, u, v, w, z, zz)


corner1 <- CV_Area_func(shallowCPUEArea2, corner1_list)
for(i in 1:nrow(corner1)) {
  corner1$startingFrom[[i]] <- "East -> West" 
}

corner10 <- CV_Area_func(shallowCPUEArea2, corner10_list)
for(i in 1:nrow(corner10)) {
  corner10$startingFrom[[i]] <- "West -> East" 
}

plotting_df <- rbind(corner1, corner10)


############

ggplot(data=plotting_df, aes(x=Area, y = CV, color = startingFrom)) + 
  #geom_point(aes(y = CV), size=2) +
  geom_line(aes(y = CV), size = 1) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=12), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=12),
        axis.title.x=element_text(size=12, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=12, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  
  scale_x_log10(breaks = c(5000, 10000, 20000, 30000, 40000), labels = c(5000, 10000, 20000, 30000, 40000)) +
  
  labs(x = "Area (km^2)", y = "CV of Total Community CUE")


```


```{r, echo=FALSE, fig.height=3.5, fig.width=8}

# Calculate and plot cumulative Species Richness vs Area

# load occurrence data
setwd("~/Google Drive/GoA project/pfx-groundfish")
occDat <-read.csv("../diversity-data/All_sp_index_occurrenceByArea.Shallow.MH.final.csv", header = T, stringsAsFactors = FALSE)
#View(occDat)
setwd("~/Google Drive/GoA project/pfx-groundfish/spatial-portfolio-project")

area1 <- area %>%
  filter(area != "Region") %>%
  mutate(area = as.numeric(area))

occDat1 <- occDat %>%
  select(area, year.numb, Species, Mean.avgPresence) %>%
  left_join(area1, by = "area")


Richness_Area_func <- function(my_df, spatialGrouping){
  
  richness_agg_list <- list()
  Area_agg_list <- list()
  df_list <- list()
  
  for(i in seq_along(spatialGrouping)) {
    
    richness_agg_list[[i]] <- my_df %>%
                              filter(area %in% spatialGrouping[[i]]) %>%
      
                              group_by(year.numb, Species) %>%
                              summarize(presenceBySpecies = max(Mean.avgPresence)) %>% # take maximum probability of occurrence of each species, in each year, for each spatialGrouping
                              ungroup() %>%
      
                              group_by(year.numb) %>%
                              summarize(spPresenceByYear = sum(presenceBySpecies)) %>% # spRichness for each year = sum of all presenceBySpecies, across all species
                              ungroup() %>%

                              summarize(spRichness = mean(spPresenceByYear)) %>% # mean spRichness across all years for each spatialGrouping
                              ungroup()
    
    
    Area_agg_list[[i]] <- my_df %>%
                          filter(area %in% spatialGrouping[[i]]) %>%
                          select(area, km2) %>%
                          group_by(area) %>%
                          summarise(eachArea = first(km2)) %>%
                          ungroup() %>%
                          summarise(area_agg = sum(eachArea))
    
    
  }
  
  df_list <- list(Area_agg_list, richness_agg_list)
  my_df <- as.data.frame(matrix(unlist(df_list), nrow=length(unlist(df_list[1]))))
  colnames(my_df) <- c("km2", "speciesRichness")
  return(my_df)
  
}


# old spatial lists:
#local_list <- c(aa, ab, ac, ad, ae, af, ag, ah, ak, al)
#local_agg_list <- c(aa, ab, ac, ad, ae, af, ag, ah, ak, al, # local communities, no aggregation
#                    a, b, c, d, e, # 2s
#                    f, fa, fb, g, n, gb, h, o, # 3s
#                    m, k, u, v, w, z, za, zb, # 4s
#                    l, t, zc, w, r, s, zd, zz, q) # the rest
#agg_only_list <- c(a, b, c, d, e, f, fa, fb, g, n, gb, h, o, m, k, u, v, w, z, za, zb, l, t, zc, w, r, s, zd, zz, q)


# run function for spatially nested aggregations of local communities:
richness2 <- Richness_Area_func(occDat1, spatially_nested_list_noSingles)
View(richness2)


# run function for random aggregations of local communities:
richness1 <- Richness_Area_func(occDat1, myNums_agg_list_noSingles)
#View(richness1)
#save(richness1, file = "richness1.RData")
load("richness1.RData")


############

# plot the result

ggplot(data=richness1, aes(x=km2, y = speciesRichness)) + 
  geom_point(aes(y = speciesRichness), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=12), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=12),
        axis.title.x=element_text(size=14, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=14, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  
  scale_x_log10(breaks = c(1000, 5000, 10000, 20000, 30000, 40000), labels = c(1000, 5000, 10000, 20000, 30000, 40000)) +
  
  labs(x = "Area (km^2)", 
       y = "Species Richness
       (sum of max. probability of occurrence)", 
       main = "Random Aggregations of Local Communities")




spRich_Area_spatNested_plot <- ggplot(data=richness2, aes(x=km2, y = speciesRichness)) + 
  geom_point(aes(y = speciesRichness), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=12), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=12),
        axis.title.x=element_text(size=14, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=14, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  
  scale_x_log10(breaks = c(1000, 5000, 10000, 20000, 30000, 40000), labels = c(1000, 5000, 10000, 20000, 30000, 40000)) +
  
  labs(x = "Area (km^2)", 
       y = "Species Richness
       (sum of max. probability of occurrence)", 
       title = "Spatially-Nested Aggregations of Local Communities")
spRich_Area_spatNested_plot
  

```



```{r, echo=FALSE, fig.height=5, fig.width=5}

# Add asynchrony calcs


# local asynchrony within sites (species-level)
sync_within_func <- function(my_df, spatialGrouping){
  
  AA_list <- list()
  Area_agg_list <- list()
  CV_agg_list <- list()
  loreau_means_list <- list()
  gross_means_list <- list()
  thibaut_means_list <- list()
  
  
  # create nested lists with 2 levels:
  AAA_list <- vector("list", length(spatialGrouping))
  loreau_list <- vector("list", length(spatialGrouping))
  gross_list <- vector("list", length(spatialGrouping))
  AAAA_list <- vector("list", length(spatialGrouping))
  rMean_list <- vector("list", length(spatialGrouping))
  thibaut_list <- vector("list", length(spatialGrouping))
  
  
#  AAA_list <- list(); loreau_list <- list(); gross_list <- list()
#  AAAA_list <- list(); rMean_list <- list(); thibaut_list <- list()
  
    
  for(j in 1:length(spatialGrouping)) {
    
    AA_list[[j]] <- my_df %>%
                    filter(area %in% spatialGrouping[[j]]) 
    
    
    # calculate summed area for each spatial grouping:
    Area_agg_list[[j]] <- AA_list[[j]] %>%
                          select(area, km2) %>%
                          group_by(area) %>%
                          summarise(eachArea = first(km2)) %>%
                          ungroup() %>%
                          summarise(area_agg = sum(eachArea))
    
    # calculate aggregate CV for each spatial grouping:
    CV_agg_list[[j]] <- AA_list[[j]] %>%
                        filter(area %in% spatialGrouping[[j]]) %>%
                        group_by(year) %>%
                        summarise(total = sum(Mean.totalDensity)) %>%
                        ungroup() %>%
                        summarise(CV = sd(total) / mean(total))
  
   
    
    
    
    
    
        ######################    
      
    for(k in 1:length(spatialGrouping[[j]])) {
      
      AAA_list[[j]][[k]] <- my_df %>%
                            filter(area %in% spatialGrouping[[j]]) %>%
                            filter(area == spatialGrouping[[j]][k]) %>%
         
                            select(year, common.name, Mean.totalDensity) %>%
                            group_by(year, common.name) %>%
                            summarize(totDensity = sum(Mean.totalDensity)) %>% # for each species in each year, sum its total density
                            ungroup()
      
       
      
   ###################### 
      
      
      loreau_list[[j]][[k]] <- codyn::synchrony(AAA_list[[j]][[k]], 
                                         time.var = "year", 
                                         species.var = "common.name", 
                                         abundance.var = "totDensity", 
                                         metric = "Loreau")
      
      
      gross_list[[j]][[k]] <- codyn::synchrony(AAA_list[[j]][[k]], 
                                         time.var = "year", 
                                         species.var = "common.name", 
                                         abundance.var = "totDensity", 
                                         metric = "Gross")     
      
      
      # Thibaut & Connolly 2013 metric:
      #rho <- ((1 - mean r_ij) / S) + mean r_ij
      # where mean r_ij = arithmetic mean correlation coefficient across all species pairs
      # perfect asynchrony: rho = 0; synchrony: rho = 1
      AAAA_list[[j]][[k]] <- AAA_list[[j]][[k]] %>%
                             spread(common.name, totDensity) %>%
                             select(-year)
      
      rMean_list[[j]][[k]] <- synchrony::meancorr(AAAA_list[[j]][[k]])$obs
      thibaut_list[[j]][[k]] <- ((1-rMean_list[[j]][[k]]) / ncol(AAAA_list[[j]][[k]])) + rMean_list[[j]][[k]]
      
      
      
      # do sums here (sum [[j]] over all [[j]][[k]])
      loreau_means_list[[j]] <- mean(loreau_list[[j]][[k]])
      
      gross_means_list[[j]] <- mean(gross_list[[j]][[k]])
      
      thibaut_means_list[[j]] <- mean(thibaut_list[[j]][[k]])
      
      
    } # end of k
    
  } # end of j
  
  
  ###################### 

  #return(gross_means_list)
  
  
  # return dataframe of outputs
  
  syn_list <- list(Area_agg_list, CV_agg_list, loreau_means_list, gross_means_list, thibaut_means_list)
  syn_df <- as.data.frame(matrix(unlist(syn_list), nrow=length(unlist(syn_list[1]))))
  colnames(syn_df) <- c("km2", "CV", "loreauSync", "grossSync", "thibautSync")
  return(syn_df)
  
}    
      

# run for random aggregations of local communities:
sync_within <- sync_within_func(shallowCPUEArea2, myNums_agg_list_noSingles)
sync_within
head(sync_within)
      
#save(sync_within, file = "sync_within_16Jan2016.RData")
load("sync_within_16Jan2016.RData")
      
#load("myNums_agg_list_noSingles.RData")
sync_within_Subdom1 <- sync_within_func(subdom1, myNums_agg_list_noSingles)
sync_within_Subdom2 <- sync_within_func(subdom2, myNums_agg_list_noSingles)
sync_within_Subdom3 <- sync_within_func(subdom3, myNums_agg_list_noSingles)
save(sync_within_Subdom1, file = "sync_within_Subdom1.RData")
save(sync_within_Subdom2, file = "sync_within_Subdom2.RData")
save(sync_within_Subdom3, file = "sync_within_Subdom3.RData")
      
    



# run for spatially-nested aggregations of local communities:
sync_within2 <- sync_within_func(shallowCPUEArea2, spatially_nested_list_noSingles)
sync_within2
head(sync_within2)  
      
      
      

# from here to line 985 is old, incorrect code which combined all local communities before evaluating between-species asynchrony:

    ###################### 
    
    AAA_list[[j]] <- AA_list[[j]] %>%
                     select(year, common.name, Mean.totalDensity) %>%
                     group_by(year, common.name) %>%
                     summarize(totDensity = sum(Mean.totalDensity)) %>% # for each species in each year, sum its total density
                     ungroup()
        
    
    # need synchrony within each local community, THEN averaged over all local communities in the spatial grouping
    
    
    # Loreau & de Mazancourt 2008 metric:
    # *********** NOT independent of stability **********
    # "This measure of synchrony is standardized between 0 (perfect asynchrony) and 1 (perfect synchrony).
    # it will return similar values for communities shaped by different processes – for example, even if 
    # species vary independently, the synchrony metric may be affected by the number of species and individual species variances."
    # "The Loreau method is based on variances, and is therefore more heavily influenced by abundant species."
    loreau_list[[j]] <- codyn::synchrony(AAA_list[[j]], 
                                         time.var = "year", 
                                         species.var = "common.name", 
                                         abundance.var = "totDensity", 
                                         metric = "Loreau")
    
    
  
    # Gross et al. 2014 metric:  
    # mean synchrony = mean correlation coefficient r between the abundances A_i of each species i 
    # versus the rest of the community (all A_j except i)
    # syn = 1/S * sum(cor(A_i, sum(A_j excluding i)))
    # where S = number of species
    # "This measure of synchrony is standardized from -1 (perfect asynchrony) to 1 (perfect synchrony) 
    # and is centered at 0 when species fluctuate independently. A virtue of this metric is it is 
    # not sensitive to richness and has the potential for null-model significance testing."
    # "... the Gross method is based on correlation and consequently weights species equally."
    gross_list[[j]] <- codyn::synchrony(AAA_list[[j]], 
                                        time.var = "year", 
                                        species.var = "common.name", 
                                        abundance.var = "totDensity", 
                                        metric = "Gross")
  
      
    
    # Thibaut & Connolly 2013 metric:
    #rho <- ((1 - mean r_ij) / S) + mean r_ij
    # where mean r_ij = arithmetic mean correlation coefficient across all species pairs
    # perfect asynchrony: rho = 0; synchrony: rho = 1
    AAAA_list[[j]] <- AAA_list[[j]] %>%
                      spread(common.name, totDensity) %>%
                      select(-year)
    rMean_list[[j]] <- synchrony::meancorr(AAAA_list[[j]])$obs
    thibaut_list[[j]] <- ((1-rMean_list[[j]]) / ncol(AAAA_list[[j]])) + rMean_list[[j]]
    
    
    
    } # end of j
  
    ###################### 

  # return dataframe of outputs
  
  syn_list <- list(Area_agg_list, CV_agg_list, loreau_list, gross_list, thibaut_list)
  syn_df <- as.data.frame(matrix(unlist(syn_list), nrow=length(unlist(syn_list[1]))))
  colnames(syn_df) <- c("km2", "CV", "loreauSync", "grossSync", "thibautSync")
  return(syn_df)
  
}


local_list <- c(aa, ab, ac, ad, ae, af, ag, ah, ak, al)
local_agg_list <- c(aa, ab, ac, ad, ae, af, ag, ah, ak, al, # local communities, no aggregation
                    a, b, c, d, e, # 2s
                    f, fa, fb, g, n, gb, h, o, # 3s
                    m, k, u, v, w, z, za, zb, # 4s
                    l, t, zc, w, r, s, zd, zz, q) # the rest
agg_only_list <- c(a, b, c, d, e, f, fa, fb, g, n, gb, h, o, m, k, u, v, w, z, za, zb, l, t, zc, w, r, s, zd, zz, q)


sync_within <- sync_within_func(shallowCPUEArea2, myNums_agg_list_noSingles)
View(sync_within)
#save(sync_within, file = "sync_within.RData")
load("sync_within.RData")



#######################

# plot CV vs synchrony

cvLoreau_within <- ggplot(data=sync_within2, aes(x=loreauSync, y = CV)) + 
  geom_point(aes(y = CV), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=12), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=12),
        axis.title.x=element_text(size=14, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=14, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  
  scale_x_reverse() +
  
  geom_smooth(method = lm) +
  
  #scale_x_log10(breaks = c(1000, 5000, 10000, 20000, 30000, 40000), labels = c(1000, 5000, 10000, 20000, 30000, 40000)) +
  
  labs(x = "Loreau Asynchrony
       (Within-patch, between species)",
       y = "CV")



cvGross_within <- ggplot(data=sync_within2, aes(x=grossSync, y = CV)) + 
  geom_point(aes(y = CV), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=16), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=16),
        axis.title.x=element_text(size=14, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=14, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  
  scale_x_reverse(breaks = c(0.05, 0.0, -0.05, -0.1, -0.15), labels = c(0.05, 0.0, -0.05, -0.1, -0.15)) +
  
  geom_smooth(method = lm, col = "red", size = 2) +
  
  #scale_x_log10(breaks = c(1000, 5000, 10000, 20000, 30000, 40000), labels = c(1000, 5000, 10000, 20000, 30000, 40000)) +
  
  labs(x = "Gross Asynchrony
       (within-patch, between species)",
       y = "CV")

#summary(lm(sync_within$CV ~ sync_within$grossSync))





cvThibaut_within <- ggplot(data=sync_within2, aes(x=thibautSync, y = CV)) + 
  geom_point(aes(y = CV), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=12), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=12),
        axis.title.x=element_text(size=14, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=14, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  
  scale_x_reverse() +
  
  geom_smooth(method = lm) +
  
  #scale_x_log10(breaks = c(1000, 5000, 10000, 20000, 30000, 40000), labels = c(1000, 5000, 10000, 20000, 30000, 40000)) +
  
  labs(x = "Thibaut Asynchrony
       (Within-patch, between species)",
       y = "CV")


grid.arrange(cvLoreau_within, cvGross_within, cvThibaut_within, ncol = 2)

#######################

# plot richness vs synchrony


# join to richness1 (make sure it was run on agg_list with individual areas too)
rich_sync_within_df <- full_join(richness1, sync_within, by = "km2")
#View(rich_sync_within_df)



CV_richness <- ggplot(data=rich_sync_within_df, aes(x=speciesRichness, y = CV)) + 
  geom_point(aes(y = CV), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=16), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=16),
        axis.title.x=element_text(size=14, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=14, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  
  #scale_x_log10(breaks = c(1000, 5000, 10000, 20000, 30000, 40000), labels = c(1000, 5000, 10000, 20000, 30000, 40000)) +
  
  geom_smooth(method = lm, col = "red", size = 2) +
  
  labs(x = "Species Richness
       (sum of max. probability of occurrence)",
       y = "CV")

CV_richness

summary(lm(rich_sync_within_df$CV ~ rich_sync_within_df$speciesRichness))
# Coefficients:
#                                      Estimate Std. Error t value Pr(>|t|)    
#(Intercept)                          0.1933799  0.0019456   99.39   <2e-16 ***
#rich_sync_within_df$speciesRichness -0.0062465  0.0001178  -53.03   <2e-16 ***
#---
#Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
#
#Residual standard error: 0.01424 on 2471 degrees of freedom
#Multiple R-squared:  0.5323,	Adjusted R-squared:  0.5321 
#F-statistic:  2812 on 1 and 2471 DF,  p-value: < 2.2e-16




richnessLoreau_within <- ggplot(data=rich_sync_within_df, aes(x=speciesRichness, y = loreauSync)) + 
  geom_point(aes(y = loreauSync), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=12), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=12),
        axis.title.x=element_text(size=14, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=14, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  
  #scale_x_log10(breaks = c(1000, 5000, 10000, 20000, 30000, 40000), labels = c(1000, 5000, 10000, 20000, 30000, 40000)) +
  
  labs(x = "Species Richness
       (sum of max. probability of occurrence)",
       y = "Loreau Synchrony")



richnessGross_within <- ggplot(data=rich_sync_within_df, aes(x=speciesRichness, y = grossSync)) + 
  geom_point(aes(y = grossSync), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=12), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=12),
        axis.title.x=element_text(size=14, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=14, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  
  #scale_x_log10(breaks = c(1000, 5000, 10000, 20000, 30000, 40000), labels = c(1000, 5000, 10000, 20000, 30000, 40000)) +
  
  labs(x = "Species Richness
       (sum of max. probability of occurrence)",
       y = "Gross Synchrony")



richnessThibaut_within <- ggplot(data=rich_sync_within_df, aes(x=speciesRichness, y = thibautSync)) + 
  geom_point(aes(y = thibautSync), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=12), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=12),
        axis.title.x=element_text(size=14, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=14, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  
  #scale_x_log10(breaks = c(1000, 5000, 10000, 20000, 30000, 40000), labels = c(1000, 5000, 10000, 20000, 30000, 40000)) +
  
  labs(x = "Species Richness
       (sum of max. probability of occurrence)",
       y = "Thibaut Synchrony")



grid.arrange(richnessLoreau_within, richnessGross_within, richnessThibaut_within, ncol = 2)

```



```{r, echo=FALSE, fig.height=5, fig.width=5}

# Synchrony between local communities (total community-level)

# ********local asynchrony within sites (species-level)**********
sync_between_func <- function(my_df, spatialGrouping){
  
  BB_list <- list()
  Area_agg_list <- list()
  CV_agg_list <- list()
  BBB_list <- list(); loreau_list <- list(); gross_list <- list()
  BBBB_list <- list(); rMean_list <- list(); thibaut_list <- list()
  
    
  for(j in 1:length(spatialGrouping)) {
    
    BB_list[[j]] <- my_df %>%
                    filter(area %in% spatialGrouping[[j]]) 
    
    
    # calculate summed area for each spatial grouping:
    Area_agg_list[[j]] <- BB_list[[j]] %>%
                          select(area, km2) %>%
                          group_by(area) %>%
                          summarise(eachArea = first(km2)) %>%
                          ungroup() %>%
                          summarise(area_agg = sum(eachArea))
    
    
    # calculate aggregate CV for each spatial grouping:
    CV_agg_list[[j]] <- BB_list[[j]] %>%
                        filter(area %in% spatialGrouping[[j]]) %>%
                        group_by(year) %>%
                        summarise(total = sum(Mean.totalDensity)) %>%
                        ungroup() %>%
                        summarise(CV = sd(total) / mean(total))
  
   
    ###################### 
    
    BBB_list[[j]] <- BB_list[[j]] %>%
                     select(area, year, common.name, Mean.totalDensity) %>%
                     group_by(area, year) %>%
                     summarize(totDensity = sum(Mean.totalDensity)) %>% # for aggregated community in each year, sum total density across all species
                     ungroup()
        
    
    
    # Loreau & de Mazancourt 2008 metric:
    # "This measure of synchrony is standardized between 0 (perfect asynchrony) and 1 (perfect synchrony).
    # it will return similar values for communities shaped by different processes – for example, even if 
    # species vary independently, the synchrony metric may be affected by the number of species and individual species variances."
    loreau_list[[j]] <- codyn::synchrony(BBB_list[[j]], 
                                         time.var = "year", 
                                         species.var = "area", 
                                         abundance.var = "totDensity", 
                                         metric = "Loreau")
    
    
  
    # Gross et al. 2014 metric:  
    # mean synchrony = mean correlation coefficient r between the abundances A_i of each species i 
    # versus the rest of the community (all A_j except i)
    # syn = 1/S * sum(cor(A_i, sum(A_j excluding i)))
    # where S = number of species
    # "This measure of synchrony is standardized from -1 (perfect asynchrony) to 1 (perfect synchrony) 
    # and is centered at 0 when species fluctuate independently. A virtue of this metric is it is 
    # not sensitive to richness and has the potential for null-model significance testing."
    gross_list[[j]] <- codyn::synchrony(BBB_list[[j]], 
                                        time.var = "year", 
                                        species.var = "area", 
                                        abundance.var = "totDensity", 
                                        metric = "Gross")
  
      
    
    # Thibaut & Connolly 2013 metric:
    #rho <- ((1 - mean r_ij) / S) + mean r_ij
    # where mean r_ij = arithmetic mean correlation coefficient across all species pairs
    # perfect asynchrony: rho = 0; synchrony: rho = 1
    BBBB_list[[j]] <- BBB_list[[j]] %>%
                      spread(area, totDensity) %>%
                      select(-year)
    rMean_list[[j]] <- synchrony::meancorr(BBBB_list[[j]])$obs
    thibaut_list[[j]] <- ((1-rMean_list[[j]]) / ncol(BBBB_list[[j]])) + rMean_list[[j]]
    
    
    
    } # end of j
  
    ###################### 
  
  # return dataframe of outputs
  
  syn_list <- list(Area_agg_list, CV_agg_list, loreau_list, gross_list, thibaut_list)
  syn_df <- as.data.frame(matrix(unlist(syn_list), nrow=length(unlist(syn_list[1]))))
  colnames(syn_df) <- c("km2", "CV", "loreauSync", "grossSync", "thibautSync")
  return(syn_df)
  
}


# run function for incomplete list of spatially-nested aggregations:
#local_list <- c(aa, ab, ac, ad, ae, af, ag, ah, ak, al)
#local_agg_list <- c(aa, ab, ac, ad, ae, af, ag, ah, ak, al, # local communities, no aggregation
#                    a, b, c, d, e, # 2s
#                    f, fa, fb, g, n, gb, h, o, # 3s
#                    m, k, u, v, w, z, za, zb, # 4s
#                    l, t, zc, w, r, s, zd, zz, q) # the rest
#agg_only_list <- c(a, b, c, d, e, f, fa, fb, g, n, gb, h, o, m, k, u, v, w, z, za, zb, l, t, zc, w, r, s, zd, zz, q)



# run function for spatially-nested aggregations of local communities:
# note I must remove single local communities to look at synchrony between communities
sync_between2 <- sync_between_func(shallowCPUEArea2, spatially_nested_list_noSingles)



# run function for random aggregations of local communities:
# note I must remove single local communities to look at synchrony between communities
sync_between <- sync_between_func(shallowCPUEArea2, myNums_agg_list_noSingles)
head(sync_between)
#save(sync_between, file = "sync_between.RData")
load("sync_between.RData")

#sync_between <- sync_between_func(shallowCPUEArea2, agg_2s)
#sync_between <- sync_between_func(shallowCPUEArea2, agg_3s)
#sync_between <- sync_between_func(shallowCPUEArea2, agg_4s)
#sync_between
#View(sync_between)
# careful; synchrony will be conflated with with the number of local communities in the analysis


sync_between_subdom1 <- sync_between_func(subdom1, myNums_agg_list_noSingles)
#save(sync_between_subdom1, file = "sync_between_subdom1.RData")
sync_between_subdom2 <- sync_between_func(subdom2, myNums_agg_list_noSingles)
#save(sync_between_subdom2, file = "sync_between_subdom2.RData")
sync_between_subdom3 <- sync_between_func(subdom3, myNums_agg_list_noSingles)
#save(sync_between_subdom3, file = "sync_between_subdom3.RData")



#######################

# plot CV vs synchrony

cvLoreau_between <- ggplot(data=sync_between2, aes(x=loreauSync, y = CV)) + 
  geom_point(aes(y = CV), size=2) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=12), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=12),
        axis.title.x=element_text(size=14, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=14, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  
  scale_x_reverse() +
  
  geom_smooth(method = lm) +
  
  #scale_x_log10(breaks = c(1000, 5000, 10000, 20000, 30000, 40000), labels = c(1000, 5000, 10000, 20000, 30000, 40000)) +
  
  labs(x = "Loreau Asynchrony
       (Between-Patch)",
       y = "CV")



cvGross_between <- ggplot(data=sync_between2, aes(x=grossSync, y = CV)) + 
  geom_point(aes(y = CV), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=16), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=16),
        axis.title.x=element_text(size=14, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=14, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  
  scale_x_reverse() +
  
  geom_smooth(method = lm, col = "red", size = 2) +
  
  #scale_x_log10(breaks = c(1000, 5000, 10000, 20000, 30000, 40000), labels = c(1000, 5000, 10000, 20000, 30000, 40000)) +
  
  labs(x = "Gross Asynchrony, Subdominant Species
       (between-patch)",
       y = "CV")

summary(lm(sync_between$CV ~ sync_between$grossSync))
# Coefficients:
#                        Estimate Std. Error t value Pr(>|t|)    
# (Intercept)            0.0861918  0.0008774   98.23   <2e-16 ***
# sync_between$grossSync 0.0532341  0.0031809   16.73   <2e-16 ***
# ---
# Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
#
# Residual standard error: 0.01923 on 799 degrees of freedom
# Multiple R-squared:  0.2596,	Adjusted R-squared:  0.2586 
# F-statistic: 280.1 on 1 and 799 DF,  p-value: < 2.2e-16

summary(lm(sync_between_subdom1$CV ~ sync_between_subdom1$grossSync))
# Coefficients:
#                                Estimate Std. Error t value Pr(>|t|)    
# (Intercept)                    0.186551   0.003213   58.06   <2e-16 ***
# sync_between_subdom1$grossSync 0.107676   0.007851   13.71   <2e-16 ***
# ---
# Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
# 
# Residual standard error: 0.04564 on 799 degrees of freedom
# Multiple R-squared:  0.1905,	Adjusted R-squared:  0.1895 
# F-statistic: 188.1 on 1 and 799 DF,  p-value: < 2.2e-16



cvThibaut_between <- ggplot(data=sync_between2, aes(x=thibautSync, y = CV)) + 
  geom_point(aes(y = CV), size=2) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=12), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=12),
        axis.title.x=element_text(size=14, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=14, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  
  scale_x_reverse() +
  
  geom_smooth(method = lm) +
  
  #scale_x_log10(breaks = c(1000, 5000, 10000, 20000, 30000, 40000), labels = c(1000, 5000, 10000, 20000, 30000, 40000)) +
  
  labs(x = "Thibaut Asynchrony
       (Between-Patch)",
       y = "CV")


grid.arrange(cvLoreau_between, cvGross_between, cvThibaut_between, ncol = 2)


#######################

# plot stuff against Species Richness

richness2s <- Richness_Area_func(occDat1, agg_2s)
richness3s <- Richness_Area_func(occDat1, agg_3s)
richness4s <- Richness_Area_func(occDat1, agg_4s)

# join to richness1 (make sure it was run on agg_list with individual areas too)
rich_sync_between_df <- full_join(richness1, sync_between, by = "km2")

rich_sync_between_df_2 <- full_join(richness2s, sync_between2, by = "km2")
rich_sync_between_df_3 <- full_join(richness3s, sync_between3, by = "km2")
rich_sync_between_df_4 <- full_join(richness4s, sync_between4, by = "km2")
View(rich_sync_between_df)



richnessLoreau_between <- ggplot(data=rich_sync_between_df, aes(x=speciesRichness, y = loreauSync)) + 
  geom_point(aes(y = loreauSync), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=12), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=12),
        axis.title.x=element_text(size=14, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=14, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  
  #scale_x_log10(breaks = c(1000, 5000, 10000, 20000, 30000, 40000), labels = c(1000, 5000, 10000, 20000, 30000, 40000)) +
  
  labs(x = "Species Richness
       (sum of max. probability of occurrence)",
       y = "Loreau Synchrony (between)")



richnessGross_between <- ggplot(data=rich_sync_between_df, aes(x=speciesRichness, y = grossSync)) + 
  geom_point(aes(y = grossSync), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=12), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=12),
        axis.title.x=element_text(size=14, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=14, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  
  #scale_x_log10(breaks = c(1000, 5000, 10000, 20000, 30000, 40000), labels = c(1000, 5000, 10000, 20000, 30000, 40000)) +
  
  labs(x = "Species Richness
       (sum of max. probability of occurrence)",
       y = "Gross Synchrony (between)")



richnessThibaut_between <- ggplot(data=rich_sync_between_df, aes(x=speciesRichness, y = thibautSync)) + 
  geom_point(aes(y = thibautSync), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=12), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=12),
        axis.title.x=element_text(size=14, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=14, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  
  #scale_x_log10(breaks = c(1000, 5000, 10000, 20000, 30000, 40000), labels = c(1000, 5000, 10000, 20000, 30000, 40000)) +
  
  labs(x = "Species Richness
       (sum of max. probability of occurrence)",
       y = "Thibaut Synchrony (between)")


# *********CAREFUL; RESULT IS CONFLATED WITH NUMBER OF LOCAL COMMUNITIES INCLUDED IN THE ANALYSIS***********
grid.arrange(richnessLoreau_between, richnessGross_between, richnessThibaut_between, ncol = 2)

```



```{r, echo=FALSE, fig.height=5, fig.width=5}

# Loreau & de Mazancourt's (2008) metric, using Tarik Gouthier's synchrony package:
#community.sync()


subdom1 <- shallowCPUEArea2 %>%
  filter(!common.name %in% c("arrowtooth flounder", "Pacific halibut", "walleye pollock", "Pacific cod"))

subdom2 <- shallowCPUEArea2 %>%
  filter(!common.name %in% c("arrowtooth flounder", "Pacific halibut", "walleye pollock", "Pacific cod", "northern rockfish", "rock soles", "Pacific ocean perch", "flathead sole"))

subdom3 <- shallowCPUEArea2 %>%
  filter(!common.name %in% c("arrowtooth flounder", "Pacific halibut"))


# for one local community:
synDat <- #shallowCPUEArea2 %>%
  #subdom2 %>%
  subdom3 %>%
  filter(area == 10) %>%
  select(common.name, year, Mean.totalDensity) %>%
  spread(common.name, Mean.totalDensity) %>%
  select(-year)

syn1 <- community.sync(synDat, nrands = 100, type = 1, alternative = c("greater"))
syn1
plot(syn1)

# 1  0.07, 0.47, 0.25, 0.23
# 2  0.17, 0.09, 0.05, 0.19
# 3  0.12, 0.28, 0.05, 0.145
# 4  0.085, 0.26, 0.06, 0.19 
# 5  0.084, 0.15, 0.07, 0.29
# 6  0.074, 0.38, 0.10, 0.22
# 7  0.074, 0.22, 0.07, 0.16
# 8  0.19, 0.16, 0.13, 0.11
# 9  0.20, 0.04, 0.06, 0.06
# 10 0.21, 0.11, 0.14, 0.07



synDat2 <- #shallowCPUEArea2 %>%
  #subdom1 %>%
  subdom3 %>%
  select(area, common.name, year, Mean.totalDensity) %>%
  
  group_by(area, year) %>%
  summarize(totDensity = sum(Mean.totalDensity)) %>%
  ungroup() %>%
  
  spread(area, totDensity) %>%
  select(-year)


syn2 <- community.sync(synDat2, nrands = 100, type = 1, alternative = c("greater"))
syn2
plot(syn2)

# 0.22, 0.38, 0.45, 0.48


#################

# Thibaut & Connolly's (2013) metric:
# use meancorr function in T. Gouhier's synchrony package:
# Compute mean column-wise correlation and determine its significance via Monte Carlo randomizations.
# The Monte Carlo randomizations are performed by shuffling the columns of the community
# matrix independently.


# for one local community:
synDat <- shallowCPUEArea2 %>%
  #subdom1 %>%
  #subdom2 %>%
  #subdom3 %>%
  filter(area == 10) %>%
  select(common.name, year, Mean.totalDensity) %>%
  spread(common.name, Mean.totalDensity) %>%
  select(-year)


rMean <- synchrony::meancorr(synDat)$obs
rho <- ((1-rMean) / ncol(synDat)) + rMean
rho




synDat2 <- #shallowCPUEArea2 %>%
  #subdom1 %>%
  subdom3 %>%
  select(area, common.name, year, Mean.totalDensity) %>%
  
  group_by(area, year) %>%
  summarize(totDensity = sum(Mean.totalDensity)) %>%
  ungroup() %>%
  
  spread(area, totDensity) %>%
  select(-year)


rMean2 <- meancorr(synDat2)$obs
rho2 <- ((1-rMean2) / ncol(synDat2)) + rMean2
rho2

# 0.17, 0.28, 0.44, 0.37

```


```{r,  include=FALSE, echo=FALSE, results='hide'}

# Wang & Loreau's average species variability (within-patch):

avSpeciesVar_within_func <- function(my_df, spatialGrouping){
  
  AA_list <- list()
  Area_agg_list <- list()
  CV_agg_list <- list()
  AAA_list <- list()
  A_list <- list(); B_list <- list(); C_list <- list()
  
    
  for(j in 1:length(spatialGrouping)) {
    
    AA_list[[j]] <- my_df %>%
                    filter(area %in% spatialGrouping[[j]]) 
    
    
    # calculate summed area for each spatial grouping:
    Area_agg_list[[j]] <- AA_list[[j]] %>%
                          select(area, km2) %>%
                          group_by(area) %>%
                          summarise(eachArea = first(km2)) %>%
                          ungroup() %>%
                          summarise(area_agg = sum(eachArea))
    
    # calculate aggregate CV for each spatial grouping:
    CV_agg_list[[j]] <- AA_list[[j]] %>%
                        filter(area %in% spatialGrouping[[j]]) %>%
                        group_by(year) %>%
                        summarise(total = sum(Mean.totalDensity)) %>%
                        ungroup() %>%
                        summarise(CV = sd(total) / mean(total))
  
   
    ###################### 
    
    AAA_list[[j]] <- AA_list[[j]] %>%
                     select(year, common.name, Mean.totalDensity) %>%
                     group_by(year, common.name) %>%
                     summarize(spTotDensity = sum(Mean.totalDensity)) %>% # for each species in each year, sum its total density across all local communities in the spatial grouping
                     ungroup()
        
    
    
    #Calculate averaged species variability (C_list$CV_species_i_squared):
  
    # calculate local community-level stuff
    A_list[[j]] <- AAA_list[[j]] %>%
      group_by(year) %>%
      summarize(annual_total_i = sum(spTotDensity)) %>% # sum CUEs across all species for each local community i in each year
      ungroup() %>%
      summarize(var_i = var(annual_total_i),
                stDev_i = sqrt(var(annual_total_i)),
                u_i = mean(annual_total_i)) # mean total community CUE (across all years) for local community (or spatial grouping) i
    
    
  # calculate species-level stuff
    B_list[[j]] <- AAA_list[[j]] %>%
      group_by(common.name) %>%
      summarize(u_j_i = mean(spTotDensity), # mean CUE (across all years) of species j in local community (or spatial grouping) i
                CV_j_i_squared = sqrt(var(spTotDensity)) / u_j_i, # CV of species j in local community i; CV = StDev / Mean
                CV_species_j_i = u_j_i / A_list[[j]]$u_i * CV_j_i_squared) %>% # CV of species j in local community i, weighted for percent contribution of each species' abundance to total abundance of local community (or spatial grouping)
      ungroup()
    
    
  # calculate averaged species variability
    C_list[[j]] <- B_list[[j]] %>%
      summarise(CV_species_i_squared = sum(CV_species_j_i))
    
  }
  
  #return(C_list)
  
  avSpVar_list <- list(Area_agg_list, CV_agg_list, C_list)
  avSpVar_df <- as.data.frame(matrix(unlist(avSpVar_list), nrow=length(unlist(avSpVar_list[1]))))
  colnames(avSpVar_df) <- c("km2", "CV", "avSpVar")
  return(avSpVar_df)

}


# run function for incomplete list of spatially-nested aggregations of local communities:
#local_list <- c(aa, ab, ac, ad, ae, af, ag, ah, ak, al)
#local_agg_list <- c(aa, ab, ac, ad, ae, af, ag, ah, ak, al, # local communities, no aggregation
#                    a, b, c, d, e, # 2s
#                    f, fa, fb, g, n, gb, h, o, # 3s
#                    m, k, u, v, w, z, za, zb, # 4s
#                    l, t, zc, w, r, s, zd, zz, q) # the rest
#agg_only_list <- c(a, b, c, d, e, f, fa, fb, g, n, gb, h, o, m, k, u, v, w, z, za, zb, l, t, #zc, w, r, s, zd, zz, q)


# run function for spatially-nested aggregations of local communities:
avSpVar_within2 <- avSpeciesVar_within_func(shallowCPUEArea2, spatially_nested_list_noSingles)


# run function for random aggregations of local communities:
avSpVar_within <- avSpeciesVar_within_func(shallowCPUEArea2, myNums_agg_list_noSingles)
avSpVar_within
#save(avSpVar_within, file = "avSpVar_within.RData")
load("avSpVar_within.RData")

avSpVar_within_subdom1 <- avSpeciesVar_within_func(subdom1, myNums_agg_list_noSingles)
#save(avSpVar_within_subdom1, file = "avSpVar_within_subdom1.RData")
avSpVar_within_subdom2 <- avSpeciesVar_within_func(subdom2, myNums_agg_list_noSingles)
#save(avSpVar_within_subdom2, file = "avSpVar_within_subdom2.RData")
avSpVar_within_subdom3 <- avSpeciesVar_within_func(subdom3, myNums_agg_list_noSingles)
#save(avSpVar_within_subdom3, file = "avSpVar_within_subdom3.RData")

#######################

# plot CV vs average species variation (within patches)

cv_AvSpVar_within <- ggplot(data=avSpVar_within2, aes(x=avSpVar, y = CV)) + 
  geom_point(aes(y = CV), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=16), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=16),
        axis.title.x=element_text(size=14, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=14, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  
  geom_smooth(method = lm, col = "red", size = 2) +
  
  #scale_x_log10(breaks = c(1000, 5000, 10000, 20000, 30000, 40000), labels = c(1000, 5000, 10000, 20000, 30000, 40000)) +
  
  labs(x = "Mean Species Variability (Within-Patch)",
       y = "CV")

cv_AvSpVar_within

grid.arrange(cv_AvSpVar_within_subdom1, cv_AvSpVar_within_subdom2, cv_AvSpVar_within_subdom3, ncol=2)

summary(lm(avSpVar_within$CV ~ avSpVar_within$avSpVar))
# Coefficients:
#                        Estimate Std. Error t value Pr(>|t|)    
# (Intercept)            -0.070121   0.006215  -11.28   <2e-16 ***
# avSpVar_within$avSpVar  0.414962   0.015507   26.76   <2e-16 ***
# ---
# Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
#
# Residual standard error: 0.01623 on 799 degrees of freedom
# Multiple R-squared:  0.4726,	Adjusted R-squared:  0.472 
# F-statistic: 716.1 on 1 and 799 DF,  p-value: < 2.2e-16

summary(lm(avSpVar_within_subdom1$CV ~ avSpVar_within_subdom1$avSpVar))
# Coefficients:
#                                Estimate Std. Error t value Pr(>|t|)    
# (Intercept)                    -0.25257    0.01153  -21.91   <2e-16 ***
# avSpVar_within_subdom1$avSpVar  0.87944    0.02116   41.56   <2e-16 ***
# ---
# Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
#
# Residual standard error: 0.02853 on 799 degrees of freedom
# Multiple R-squared:  0.6837,	Adjusted R-squared:  0.6833 
# F-statistic:  1727 on 1 and 799 DF,  p-value: < 2.2e-16

```



Although we can compare local and regional community stability using CVs alone, here we calculate metrics from Wang & Loreau (2014) to help us think about mechanisms underlying this result.
The following uses formulas from Wang & Loreau's (2014) Supp Mat (i.e. for the case where biomass varies within and between local communities).
```{r,  include=FALSE, echo=FALSE, results='hide'}

# CONSIDER WHETHER TO LOG THE CUES FIRST


# nomenclature for the following calculations:
# i, h = local community i (and h)
# j, k, l = species j, k, l
# j_i = species j in local community i
# u = mean
# w = variance or covariance
# w_kk_i = variance of each species k within local community i
# w_kl_i = covariance between species k and l within local community i
# w_ii = variance (of total community CPUE) for each local community i
# w_ih = covariance (of total community CPUE) between local communities i & h
# rho = temporal Synchrony; inverse is Beta (temporal Asynchrony)


WangLoreau_func <- function(this_df, spatialGrouping){
  
  # create single-level lists:
  Area_agg_list <- list()
  AA_list <- list()#; AAA_list <- list()
  another_df_list <- list(); covMatrix_m_list <- list(); w_ii_list <- list(); w_ih_list <- list()
  summed_w_ih_list <- list(); rho_list <- list(); Beta1_list <- list(); gamma_CV_list <- list()
  

  # create nested lists with 2 levels:
  AAA_list <- vector("list", length(spatialGrouping))
  A_list <- vector("list", length(spatialGrouping))
  B_list <- vector("list", length(spatialGrouping))
  C_list <- vector("list", length(spatialGrouping))
  D_list <- vector("list", length(spatialGrouping))
  E_list <- vector("list", length(spatialGrouping))
  F_list <- vector("list", length(spatialGrouping))
  covMatrix_i_list <- vector("list", length(spatialGrouping))
  w_kk_i_list <- vector("list", length(spatialGrouping))
  rho_species_i_list <- vector("list", length(spatialGrouping)) 
  CV_i_list <- vector("list", length(spatialGrouping))
  u_m_list <- vector("list", length(spatialGrouping))
  alpha_CV_list <- vector("list", length(spatialGrouping))


  
    ###################### 
  
  
    for(j in 1:length(spatialGrouping)) {
      
      AA_list[[j]] <- this_df %>%
        filter(area %in% spatialGrouping[[j]]) 
    
      
      # calculate summed area for each spatial grouping:
      Area_agg_list[[j]] <- AA_list[[j]] %>%
        select(area, km2) %>%
        group_by(area) %>%
        summarise(eachArea = first(km2)) %>%
        ungroup() %>%
        summarise(area_agg = sum(eachArea))
  
        
    ######################    
      
    for(k in 1:length(spatialGrouping[[j]])) {
      
       AAA_list[[j]][[k]] <- this_df %>%
         filter(area %in% spatialGrouping[[j]]) %>%
         filter(area == spatialGrouping[[j]][k])
      
       
      
   ###################### 
       
  # 1. Calculate averaged species variability (C_list$CV_species_i_squared):
  
  # calculate local community-level stuff
    A_list[[j]][[k]] <- AAA_list[[j]][[k]] %>%
      group_by(year) %>%
      summarise(annual_total_i = sum(Mean.totalDensity)) %>% # sum CUEs across all species for each local community in each year
      ungroup() %>%
      summarise(var_i = var(annual_total_i),
                stDev_i = sqrt(var(annual_total_i)),
                u_i = mean(annual_total_i)) # mean total community CUE (across all years) for local community i
    
    
  # calculate species-level stuff
    B_list[[j]][[k]] <- AAA_list[[j]][[k]] %>%
      group_by(Species) %>%
      summarise(u_j_i = mean(Mean.totalDensity), # mean CUE (across all years) of species j in local community i
                CV_j_i_squared = sqrt(var(Mean.totalDensity)) / u_j_i, # CV of species j in local community i; CV = StDev / Mean
                CV_species_j_i = u_j_i / A_list[[j]][[k]]$u_i * CV_j_i_squared) %>% # CV of species in local community i
      ungroup()
    
    
  # calculate averaged species variability
    C_list[[j]][[k]] <- B_list[[j]][[k]] %>%
      summarise(CV_species_i_squared = sum(CV_species_j_i))
    
    
    
      ##############################
    
  # 2. Calculate species asynchrony WITHIN local areas (rho_species_i_list):
    D_list[[j]][[k]] <- AAA_list[[j]][[k]] %>%
      select(year, Mean.totalDensity, Species) %>%
      spread(Species, Mean.totalDensity) %>%
      select(-year)
    
    covMatrix_i_list[[j]][[k]] <- cov(D_list[[j]][[k]]) # create the covariance matrix
    
    w_kk_i_list[[j]][[k]] <- diag(covMatrix_i_list[[j]][[k]]) # extract diagonals of the covariance matrix. these are temporal variance of each species k within local community i
    
    covMatrix_i_list[[j]][[k]][upper.tri(covMatrix_i_list[[j]][[k]], diag = TRUE)] <- NA # for each local community i, keep one copy of all the non-diagonals. these are w_kl_i
    E_list[[j]][[k]] <- as.data.frame(covMatrix_i_list[[j]][[k]])
    
    F_list[[j]][[k]] <- E_list[[j]][[k]] %>%
       summarise(sum_w_kl_i = sum(E_list[[j]][[k]][,1:53], na.rm = T)) # for each local community i, find the sum of all w_kl_i. calc has been checked
    
    rho_species_i_list[[j]][[k]] <- F_list[[j]][[k]]$sum_w_kl_i / ((sum(sqrt(w_kk_i_list[[j]][[k]][1:53])))^2)
  
  
  ##############################
  # 3. Calculate Variability of local community k
    CV_i_list[[j]][[k]] <- C_list[[j]][[k]]$CV_species_i_squared * rho_species_i_list[[j]][[k]] # It's not clear whether this should be squared. If not squred, returns a negative value when within-patch species synchrony is negative
  # CHECK WHETHER LOCAL COMMUNITY VARIABILITY CORRELATES WITH SIZE (AREA) OF LOCAL COMMUNITY (IE DO LARGER AREAS SHOW MORE VARIABILITY?)


  ##############################
  # 4. Calculate Alpha variability (local community variability weighed for local community CPUE)
    u_m_list[[j]] <- sum(A_list[[j]][[k]]$u_i)
    alpha_CV_list[[j]] <- (sum(A_list[[j]][[k]]$u_i / u_m_list[[j]] * CV_i_list[[j]][[k]]))^2
  
    
  ##############################
    
    } # end of k
    

  ############################################################
  # 5. Calculate Beta variability (spatial synchrony; rho)
  # note I'm replacing Wang & Loreau's local patch i & j notation with i & h, to avoid confusion with their species j
    
  another_df_list[[j]] <- AA_list[[j]] %>%  
    group_by(area, year) %>%
    summarise(ann_tot_i = sum(Mean.totalDensity)) %>%
    ungroup() %>%
    spread(area, ann_tot_i) %>%
    select(-year)
  
  
    covMatrix_m_list[[j]] <- cov(another_df_list[[j]]) # create the covariance matrix of each local community j
  
    w_ii_list[[j]] <- diag(covMatrix_m_list[[j]]) # extract diagonals of the covariance matrix. returns a vector. this is temporal variance of total community CPUE, within each local community j.
  
    covMatrix_m_list[[j]][upper.tri(covMatrix_m_list[[j]], diag = TRUE)] <- NA # keep one copy of all the non-diagonals. These are w_ih (temporal covariance of total community biomass between local patches i & h). NB it would be nice to bring in species-level information here, to prevent dominant species from driving the result.
    w_ih_list[[j]] <- as.data.frame(covMatrix_m_list[[j]])
  
    summed_w_ih_list[[j]] <- w_ih_list[[j]] %>% 
      summarise(sum_w_ih = sum(w_ih_list[[j]][,1:ncol(w_ih_list[[j]])], na.rm = T)) # find the sum of all w_ih. calc has been checked

    rho_list[[j]] <- summed_w_ih_list[[j]]$sum_w_ih / ((sum( sqrt(w_ii_list[[j]][1:length(w_ii_list[[j]])]) ))^2) # Wang & Loreau (2014) claim that standardizing for within-patch covariance accounts for spatial uneveness in biomass. Not sure about this.
  
    Beta1_list[[j]] <- 1 / rho_list[[j]]


  ##############################
  # 6. Calculate Gamma variability
  
  gamma_CV_list[[j]] <- alpha_CV_list[[j]] / Beta1_list[[j]]
  
  
    } # end of j
  
  
  ##############################
  
  # 7. Return dataframe of outputs
  
    WangLoreau_list <- list(Area_agg_list, alpha_CV_list, rho_list, gamma_CV_list)
    WangLoreau_df <- as.data.frame(matrix(unlist(WangLoreau_list), nrow=length(unlist(WangLoreau_list[1]))))
    colnames(WangLoreau_df) <- c("Area", "alphaCV", "Rho", "gammaCV")
    return(WangLoreau_df)
  
}


WangLoreauResult <- WangLoreau_func(shallowCPUEArea2, myNums_agg_list)
WangLoreauResult


#alpha <- plot(log(WangLoreauResult$gammaCV) ~ log(WangLoreauResult$alphaCV), pch=16, cex=1.5)
#rho <- plot(log(WangLoreauResult$gammaCV) ~ log(WangLoreauResult$Rho), pch=16, cex=1.5)

```



```{r,  echo=FALSE, fig.height=4, fig.width=5}

# Create spatial groupings for pairwise dissimilarity indices:

# 1. Create k subgroupings of local communities
a <- list(1:2)
b <- list(3:4)
c <- list(5:6)
d <- list(7:8)
e <- list(9:10)

f <- list(1:3)
g <- list(4:6)
h <- list(5:7)
m <- list(8:10)

q <- list(1:4)
r <- list(5:8)
s <- list(3:6)
t <- list(7:10)

u <- list(1:5)
v <- list(6:10)


# 2. Create j pairs of k subgroupings
b1 <- c(a, b)  # 1:2, 3:4
b2 <- c(b, c)  # 3:4, 5:6
b3 <- c(c, d)  # 5:6, 7:8
b4 <- c(d, e)  # 7:8, 9:10

b5 <- c(f, g) # 1:3, 4:6
b6 <- c(h, m) # 5:7, 8:10

b7 <- c(q, r) # 1:4, 5:8
b8 <- c(s, t) # 3:6, 7:10

b9 <- c(u, v) # 1:5, 6:10


# 3. Create list of j pairs
#spatialPairs <- list(b1, b2, b3, b4)
spatialPairs <- list(b1, b2, b3, b4, b5, b6, b7, b8, b9)



##################################


# Calculate Bray spatial turnover for list of random draws:


# need nested list of paired lists
# either split each list in half inside the function

# or create a new nested list of paired lists (with random numbers)

# or take random draws of elements of myNums4_list (or myNums_agg_list or myNums_agg_list_noSingles) to create paired lists:
# 2. Create j pairs of k subgroupings (nested list)
b1 <- c(a, b)  # 1:2, 3:4


bray_func <- function(your_df, spatialGrouping){
  
  
  # create flat lists:
  pair_list <- list()
  wisc_list <- list()
  bray_list <- list()
  #comm_agg_list <- list()
  CV_list <- list()
  Area_agg_list <- list()
  
  
  # create nested lists with 2 levels:
  subpair_list <- vector("list", length(spatialGrouping))
  subpair_df_list <- vector("list", length(spatialGrouping)) 
  
  
  ##############################
  
  # 1. Loop over list of j pairs to create pairs for Bray matrix
    
  for(j in 1:length(spatialGrouping)) { # ie for each of 801 elements in myNums_agg_list_noSingles
    
    # split each spatialGrouping in half:
    subpair_list[[j]][[1]] <- spatialGrouping[[j]][1 : (ceiling(length(spatialGrouping[[j]])/2)) ]
    subpair_list[[j]][[2]] <- spatialGrouping[[j]][ ((ceiling(length(spatialGrouping[[j]])/2))+1) : length(spatialGrouping[[j]])]
    
    
    # now loop over subpair_list
    subpair_df_list[[j]][[1]] <- your_df %>%
                                filter(area %in% subpair_list[[j]][[1]]) %>%
                                select(common.name, Mean.totalDensity, area, year) %>%
                                group_by(common.name) %>%
                                summarize(temporal.mean = mean(Mean.totalDensity)) %>%
                                ungroup() %>%
                                spread(common.name, temporal.mean)
    
     subpair_df_list[[j]][[2]] <- your_df %>%
                                filter(area %in% subpair_list[[j]][[2]]) %>%
                                select(common.name, Mean.totalDensity, area, year) %>%
                                group_by(common.name) %>%
                                summarize(temporal.mean = mean(Mean.totalDensity)) %>%
                                ungroup() %>%
                                spread(common.name, temporal.mean)
    
     # area groupings work as expected
     
     ##############################
    
    # 2. Calculate Bray dissimilarities
    
    pair_list[[j]] <- bind_rows(subpair_df_list[[j]]) # bind dfs in subpair_list with the same j
    wisc_list[[j]] <- wisconsin(pair_list[[j]]) # Wisconsin transformation. Consider also wisconsin(sqrt(x)). Check that I'm combining these in the right way.
    bray_list[[j]] <- vegdist(wisc_list[[j]], "bray") # calculate Bray-Curtis dissimilarities for each j pair of k local communities

    
    ##############################
    
    # 4. add calcs for cumulative species richness and CV for each j grouping of local communities
    # note I need occurrence data for species Richness
    
    #comm_agg_list[[j]] <- unlist(subpair_list[[j]]) # unlist the nested list of site pairs
    # can't I just use spatialGrouping[[j]]?
    
    # calculate CV and cumulative area
    # should I be taking the mean CV of each subpair within each j, then take the mean CV of these two?
    CV_list[[j]] <- your_df %>%
                    filter(area %in% spatialGrouping[[j]]) %>%
                    group_by(year) %>%
                    summarise(total = sum(Mean.totalDensity)) %>%
                    ungroup() %>%
                    summarise(CV = sd(total) / mean(total))
        
    
    # calculate summed area for each spatial grouping:
    Area_agg_list[[j]] <- your_df %>%
                          filter(area %in% spatialGrouping[[j]]) %>%
                          select(area, km2) %>%
                          group_by(area) %>%
                          summarise(eachArea = first(km2)) %>%
                          ungroup() %>%
                          summarise(area_agg = sum(eachArea))
    
      
    } # end of j
  
  
    ##############################
  
    # 5. Return dataframe of outputs
  
    bray_list <- list(bray_list, CV_list, Area_agg_list)
    bray_df <- as.data.frame(matrix(unlist(bray_list), nrow=length(unlist(bray_list[1]))))
    colnames(bray_df) <- c("bray", "CV", "km2")
    return(bray_df)
    
  
}


#brayResult <- bray_func(shallowCPUEArea2, myNums4_list)
#brayResult


# run function for spatially-nested aggregations of local communities:
brayResult2 <- bray_func(shallowCPUEArea2, spatially_nested_list_noSingles)
brayResult2_subdom1 <- bray_func(subdom1, spatially_nested_list_noSingles)
brayResult2_subdom2 <- bray_func(subdom2, spatially_nested_list_noSingles)
brayResult2_subdom3 <- bray_func(subdom3, spatially_nested_list_noSingles)


# run function for random aggregations of local communities:
brayResult <- bray_func(shallowCPUEArea2, myNums_agg_list_noSingles)
brayResult
#save(brayResult, file = "brayResult.RData")
load("brayResult.RData")

brayResult_subdom1 <- bray_func(subdom1, myNums_agg_list_noSingles)
#save(brayResult_subdom1, file = "brayResult_subdom1.RData")
brayResult_subdom2 <- bray_func(subdom2, myNums_agg_list_noSingles)
#save(brayResult_subdom2, file = "brayResult_subdom2.RData")
brayResult_subdom3 <- bray_func(subdom3, myNums_agg_list_noSingles)
#save(brayResult_subdom3, file = "brayResult_subdom3.RData")

#####################


plot(brayResult$CV ~ brayResult$km2, pch=16, cex=2.5)
plot(brayResult$bray ~ brayResult$km2, pch=16, cex=2.5)
plot(brayResult$CV ~ brayResult$bray, pch=16, cex=2.5)
summary(lm(brayResult$CV ~ brayResult$bray))



# plot it
# CAREFUL, how to remove effect of Area (km^2) and number of local communities on CV? Because lower bray is associated with greater number of local communities. 
# And it's not really clear what Bray dissimilarities mean here for progressively aggregated communities.

CV_bray_plot_subdom3 <- ggplot(data=brayResult2_subdom3, aes(x=bray, y = CV)) + 
  geom_point(aes(y = CV), size=2) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=12), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=12),
        axis.title.x=element_text(size=14, margin=margin(15,0,0,0)),
        axis.title.y=element_text(size=14, angle=90, margin=margin(0,15,0,0)),
        plot.title = element_text(size=18)) +
  
  #scale_x_log10(breaks = c(5000, 10000, 20000, 30000, 40000), labels = c(5000, 10000, 20000, 30000, 40000)) +
  
  #scale_y_log10() +
  
  geom_smooth(method = lm, col = "red", size = 2) +
  
  labs(x = "Bray Dissimilarity", y = "CV (Total Community CUE)", title = "Subdom3")

grid.arrange(CV_bray_plot_subdom1, CV_bray_plot_subdom2, CV_bray_plot_subdom3, ncol=2)

summary(lm(brayResult$CV ~ brayResult$bray))
# Coefficients:
#                 Estimate Std. Error t value Pr(>|t|)    
# (Intercept)     0.086474   0.002500  34.592  < 2e-16 ***
# brayResult$bray 0.033955   0.008952   3.793  0.00016 ***
# ---
# Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
#
# Residual standard error: 0.02215 on 799 degrees of freedom
# Multiple R-squared:  0.01769,	Adjusted R-squared:  0.01646 
# F-statistic: 14.39 on 1 and 799 DF,  p-value: 0.0001601


summary(lm(brayResult_subdom1$CV ~ brayResult_subdom1$bray))
# Coefficients:
#                         Estimate Std. Error t value Pr(>|t|)    
# (Intercept)              0.20512    0.00588  34.886  < 2e-16 ***
# brayResult_subdom1$bray  0.07200    0.02065   3.488 0.000514 ***
# ---
# Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
#
# Residual standard error: 0.05035 on 799 degrees of freedom
# Multiple R-squared:  0.01499,	Adjusted R-squared:  0.01376 
# F-statistic: 12.16 on 1 and 799 DF,  p-value: 0.0005141


summary(lm(brayResult2$CV ~ brayResult2$bray))
# Coefficients:
#                  Estimate Std. Error t value Pr(>|t|)    
# (Intercept)       0.16073    0.01665   9.652  2.5e-12 ***
# brayResult2$bray -0.17231    0.05780  -2.981  0.00471 ** 
# ---
# Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
# 
# Residual standard error: 0.03208 on 43 degrees of freedom
# Multiple R-squared:  0.1713,	Adjusted R-squared:  0.152 
# F-statistic: 8.887 on 1 and 43 DF,  p-value: 0.004713

```


```{r,  include=FALSE, echo=FALSE, results='hide'}

# Calculate Bray spatial turnover:

bray_func <- function(your_df, pairs){
  
  
  # create flat lists:
  pair_list <- list()
  wisc_list <- list()
  bray_list <- list()
  comm_agg_list <- list()
  CV_list <- list()
  Area_agg_list <- list()
  
  
  # create nested lists with 2 levels:
  subpair_list <- vector("list", length(pairs))
  
  
  ##############################
  
  # 1. Loop over list of j pairs to create pairs for Bray matrix
    
  for(j in 1:length(pairs)) {
    
    
  ##############################
    
  # 2. Create aggregated df's for each k sub-pair of local communities  
    
    for(k in 1:length(pairs[[j]])) {
      
       # length(spatialPairs) == 4
       # length(spatialPairs[[j]]) == 2
       # length(spatialPairs[[j]][[k]]) == 2
      
      subpair_list[[j]][[k]] <- your_df %>%
                                filter(area %in% pairs[[j]][[k]]) %>%
                                select(common.name, Mean.totalDensity, area, year) %>%
                                group_by(common.name) %>%
                                summarize(temporal.mean = mean(Mean.totalDensity)) %>%
                                ungroup() %>%
                                spread(common.name, temporal.mean)
       
      
          
       } # end of k
    
    
    ##############################
    
    # 3. Calculate Bray dissimilarities (back to loop for [[j]])
    
    pair_list[[j]] <- bind_rows(subpair_list[[j]]) # bind dfs in subpair_list with the same j
    wisc_list[[j]] <- wisconsin(pair_list[[j]]) # Wisconsin transformation. Consider also wisconsin(sqrt(x)). Check that I'm combining these in the right way.
    bray_list[[j]] <- vegdist(wisc_list[[j]], "bray") # calculate Bray-Curtis dissimilarities for each j pair of k local communities
  
    
    
    ##############################
    
    # 4. add calcs for cumulative species richness and CV for each j grouping of local communities
    # note I need occurrence data for species Richness
    
    comm_agg_list[[j]] <- unlist(pairs[[j]])
    
    # calculate CV and cumulative area
    # should I be taking the mean CV of each subpair within each j, then take the mean CV of these two?
    CV_list[[j]] <- your_df %>%
                    filter(area %in% comm_agg_list[[j]]) %>%
                    group_by(year) %>%
                    summarise(total = sum(Mean.totalDensity)) %>%
                    ungroup() %>%
                    summarise(CV = sd(total) / mean(total))
        
    
    # calculate summed area for each spatial grouping:
    Area_agg_list[[j]] <- your_df %>%
                          filter(area %in% comm_agg_list[[j]]) %>%
                          select(area, km2) %>%
                          group_by(area) %>%
                          summarise(eachArea = first(km2)) %>%
                          ungroup() %>%
                          summarise(area_agg = sum(eachArea))
    
      
    } # end of j
  
  
    ##############################
  
    # 5. Return dataframe of outputs
  
    bray_list <- list(bray_list, CV_list, Area_agg_list)
    bray_df <- as.data.frame(matrix(unlist(bray_list), nrow=length(unlist(bray_list[1]))))
    colnames(bray_df) <- c("bray", "CV", "km2")
    return(bray_df)
    
  
}


brayResult <- bray_func(shallowCPUEArea2, spatialPairs) 
#brayResult




#shallow_mat1 <- spatial_func(shallowCPUEArea2)  
#shallow.dis.bray.wisc <- vegdist(shallow_mat1, "bray", upper = TRUE, lower=TRUE)  # get Bray-Curtis dissimilarities 
#shallow_mean_spatial <- colSums(as.data.frame(as.matrix(shallow.dis.bray.wisc)))/9 # calculate mean dissimilarity between each local community and all other local communities



```



```{r, echo=F, fig.height=10, fig.width=10}

# plot stuff

alphaCV_plot <- ggplot(data=WangLoreauResult, aes(x=Area, y = alphaCV)) + 
  geom_point(aes(y = alphaCV), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=8), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=10),
        axis.title.x=element_text(size=12, margin=margin(7,0,0,0)),
        axis.title.y=element_text(size=12, angle=90, margin=margin(0,7,0,0)),
        plot.title = element_text(size=18)) +
  
  scale_x_log10(breaks = c(5000, 10000, 20000, 30000, 40000), labels = c(5000, 10000, 20000, 30000, 40000)) +
  
  scale_y_log10() +
  
  geom_smooth(method = lm, se = FALSE) +
  
  labs(x = "Area (km^2)", 
       y = "Alpha CV")




rho_plot <- ggplot(data=WangLoreauResult, aes(x=Area, y = Rho)) + 
  geom_point(aes(y = Rho), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=8), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=10),
        axis.title.x=element_text(size=12, margin=margin(7,0,0,0)),
        axis.title.y=element_text(size=12, angle=90, margin=margin(0,7,0,0)),
        plot.title = element_text(size=18)) +
  
  scale_x_log10(breaks = c(5000, 10000, 20000, 30000, 40000), labels = c(5000, 10000, 20000, 30000, 40000)) +
  
  scale_y_log10(breaks = c(0.001, 0.01, 0.1, 0.2), labels = c(0.001, 0.01, 0.1, 0.2)) +
  
  geom_smooth(method = lm, se = FALSE) +
  
  labs(x = "Area (km^2)", 
       y = "Rho")
  
  




gammaCV_plot <- ggplot(data=WangLoreauResult, aes(x=Area, y = gammaCV)) + 
  geom_point(aes(y = gammaCV), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=8), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=10),
        axis.title.x=element_text(size=12, margin=margin(7,0,0,0)),
        axis.title.y=element_text(size=12, angle=90, margin=margin(0,7,0,0)),
        plot.title = element_text(size=18)) +
  
  scale_x_log10(breaks = c(5000, 10000, 20000, 30000, 40000), labels = c(5000, 10000, 20000, 30000, 40000)) +
  
  scale_y_log10(breaks = c(0.00000001, 0.0000001, 0.000001, 0.00001, 0.0001), labels = c(0.00000001, 0.0000001, 0.000001, 0.00001, 0.0001)) +
  
  geom_smooth(method = lm, se = FALSE) +
  
  labs(x = "Area (km^2)", 
       y = "Gamma CV")




grid.arrange(alphaCV_plot, rho_plot, gammaCV_plot, ncol = 2)

```




```{r, echo=F, fig.height=10, fig.width=10}

# plot more stuff

# bind all dataframes together:
mydat <- list(richness1, allCV, WangLoreauResult) %>%
  Reduce(function(x, y) left_join(x, y, by="Area"), .) %>%
  distinct()



gammaCV_spRichness <- ggplot(data=mydat, aes(x=speciesRichness, y = gammaCV)) + 
  geom_point(aes(y = gammaCV), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=12), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=12),
        axis.title.x=element_text(size=14, margin=margin(7,0,0,0)),
        axis.title.y=element_text(size=14, angle=90, margin=margin(0,7,0,0)),
        plot.title = element_text(size=18)) +
  
  #scale_x_log10(breaks = c(5000, 10000, 20000, 30000, 40000), labels = c(5000, 10000, 20000, 30000, 40000)) +
  
  scale_y_log10(breaks = c(0.00000001, 0.0000001, 0.000001, 0.00001, 0.0001), labels = c(0.00000001, 0.0000001, 0.000001, 0.00001, 0.0001)) +
  
  geom_smooth(method = lm, se = FALSE) +
  
  labs(x = "Species Richness
 (max. probability of occurrence)", 
       y = "Gamma CV")




CV_spRichness <- ggplot(data=mydat, aes(x=speciesRichness, y = CV)) + 
  geom_point(aes(y = CV), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=12), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=12),
        axis.title.x=element_text(size=14, margin=margin(7,0,0,0)),
        axis.title.y=element_text(size=14, angle=90, margin=margin(0,7,0,0)),
        plot.title = element_text(size=18)) +
  
  #scale_y_log10(breaks = c(0.00000001, 0.0000001, 0.000001, 0.00001, 0.0001), labels = c(0.00000001, 0.0000001, 0.000001, 0.00001, 0.0001)) +
  
  geom_smooth(method = lm, se = FALSE) +
  
  labs(x = "Species Richness
 (max. probability of occurrence)", 
       y = "CV of Total Community CUE")




CV_gammaCV_raw_scale <- ggplot(data=mydat, aes(x=CV, y = gammaCV)) + 
  geom_point(aes(y = gammaCV), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=12), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=12),
        axis.title.x=element_text(size=14, margin=margin(7,0,0,0)),
        axis.title.y=element_text(size=14, angle=90, margin=margin(0,7,0,0)),
        plot.title = element_text(size=18)) +
  
  labs(x = "CV of Total Community CUE", 
       y = "Gamma CV")




CV_gammaCV_log_scale <- ggplot(data=mydat, aes(x=CV, y = gammaCV)) + 
  geom_point(aes(y = gammaCV), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black"),
        axis.text.x = element_text(margin=margin(5,0,0,0), size=12), 
        axis.text.y = element_text(margin=margin(0,5,0,0), size=12),
        axis.title.x=element_text(size=14, margin=margin(7,0,0,0)),
        axis.title.y=element_text(size=14, angle=90, margin=margin(0,7,0,0)),
        plot.title = element_text(size=18)) +
  
  scale_y_log10(breaks = c(0.00000001, 0.0000001, 0.000001, 0.00001, 0.0001), labels = c(0.00000001, 0.0000001, 0.000001, 0.00001, 0.0001)) +
  
  #geom_smooth(method = lm, se = FALSE) +
  
  labs(x = "CV of Total Community CUE", 
       y = "Gamma CV")



grid.arrange(CV_spRichness, gammaCV_spRichness, CV_gammaCV_raw_scale, CV_gammaCV_log_scale, ncol = 2)

```










###Within-patch sums of all between-species covariances. Negative values indicate asynchrony.
```{r, echo=F, fig.height=2.75, fig.width=4}
# F_list
F_df <- data.frame(matrix(NA_real_, nrow = 9, ncol = 2)); 
colsF <- c("Area", "sum_w_kl_i"); colnames(F_df) <- colsF
areaNum <- as.vector(1:9); F_df[,1] <- as.factor(areaNum)

for(i in seq_along(F_list)) {
  F_df[i,2] <- data.frame(as.data.frame(F_list[[i]]$sum_w_kl_i))
}


# plot
cov.within_shallow <- ggplot(data=F_df, aes(x=areaNum, y = sum_w_kl_i)) + 
  geom_point(aes(y = sum_w_kl_i), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black")) +
  
  scale_x_continuous(breaks = c(1:9)) +
  
  labs(x = "Area", y = "sum_w_kl_i", title = "Shallow Areas")

cov.within_shallow
```


```{r, include=FALSE, echo=FALSE, results='hide'}
# Within-patch species asynchrony:
# rho_species_i_list
rho_sp_df <- data.frame(matrix(NA_real_, nrow = 9, ncol = 2)); 
cols_rho_sp <- c("Area", "rho_species_i"); colnames(rho_sp_df) <- cols_rho_sp
areaNum <- as.vector(1:9); rho_sp_df[,1] <- as.factor(areaNum)

for(i in seq_along(rho_species_i_list)) {
  rho_sp_df[i,2] <- data.frame(as.data.frame(rho_species_i_list[[i]]))
}


# plot
asynch.within <- ggplot(data=rho_sp_df, aes(x=areaNum, y = rho_species_i)) + 
  geom_point(aes(y = rho_species_i), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black")) +
  
  scale_x_continuous(breaks = c(1:9)) +
  
  labs(x = "Area", y = "rho_species_i")

asynch.within
```


```{r, include=FALSE, echo=FALSE, results='hide'}
# Within-patch variability (ie CVs of total community CPUE within local communities):
# CV_i_list
CV_i_df <- data.frame(matrix(NA_real_, nrow = 9, ncol = 2)); 
cols_CV_i <- c("Area", "CV_i"); colnames(CV_i_df) <- cols_CV_i
areaNum <- as.vector(1:9); CV_i_df[,1] <- as.factor(areaNum)

for(i in seq_along(CV_i_list)) {
  CV_i_df[i,2] <- data.frame(as.data.frame(CV_i_list[[i]]))
}

# plot
CV.within <- ggplot(data=CV_i_df, aes(x=areaNum, y = CV_i)) + 
  geom_point(aes(y = CV_i), size=5) +
  
  theme(panel.background = element_blank(),
        axis.line.x = element_line(color="black"),
        axis.line.y = element_line(color="black")) +
  
  scale_x_continuous(breaks = c(1:9)) +
  
  labs(x = "Area", y = "CV_i")

CV.within
```


###Alpha variability (temporal variability at the local scale (NB weighed for local community biomass)):
```{r}
alpha_CV
```


### Spatial synchrony:
```{r}
rho
```


### Within-patch variance (ie temporal variance of each local area's total community CPUE, within local communities):
```{r}
w_ii
```


### Temporal covariance of total community CPUE between all pairs of local communities. Broadly speaking, local areas 1-6 covary positively with eachother, as do areas 7-9. Areas 1-6 covary negatively with 7-9.
```{r}
w_ih
```


###Beta variability (Multiplicative beta variability, i.e. the degree of spatial asynchrony):
```{r}
Beta1
```


###Gamma variability (temporal variability at the metacommunity scale):
```{r}
gamma_CV
```

